      program pole8
c
c ***********************************************************************
c ***   program pole8   ***   version 23/MAR/2016  ***  Carlos Tome   ***
c ***********************************************************************
c *** This program makes pole figure representations starting from a  ***
c *** texture file containing a set of Euler angles with weights and  ***
c *** a list with the indices of poles to be plotted.                 ***
c ***                                                                 ***
c *** Creates an output file POLE8.OUT containing the information     ***
c *** about the pole figure for plotting with PLOTPF8.FOR.            ***
c *** Creates separate output files for plotting with any other       ***
c *** graphics software.                                              ***
c ***                                                                 ***
c *** It features the following options:                              ***
c ***     * handles Bunge, Kocks and Roe conventions.                 ***
c ***     * handles any crystal symmetry (cubic to triclinic)         ***
c ***     * handles several texture files simultaneously.             ***
c ***     * handles texture files with more than one texture in it.   ***
c ***     * can plot several poles for several textures in one run.   ***
c ***     * plots dots or intensity lines.                            ***
c ***     * plots equal area or stereographic representation.         ***
c ***     * (phi,theta) or (phi,cos(theta)) grid.                     ***
c ***     * optional symmetrization of the original set of poles.     ***
c ***     * for axial symmetrization outputs azimuthal intens profile ***
c ***     * 'gaussian' spreading of the poles.                        ***
c ***     * plots intensities in equal, geometric or arbitrarily      ***
c ***       spaced levels.                                            ***
c ***     * plots inverse pole figures for all symmetries.            ***
c ***********************************************************************
c ***     calls subroutines:   circles                                ***
c ***                          concatenate                            ***
c ***                          crystal_symmetry                       ***
c ***                          euler                                  ***
c ***                          isolev                                 ***
c ***                          linint                                 ***
c ***                          project                                ***
c ***                          read_popla_epf                         ***
c ***                          read_popla_sod                         ***
c ***                          read_texture_files                     ***
c ***                          spread_poles                           ***
c ***                          texture                                ***

C *** SUBROUTINE ORTHO  
C     GENERATES MIRROR RELATED ORIENTATIONS BY 'MIRRORING' THE AXES
C     OF THE CRYSTAL IN SAMPLE AXES (ROWS OF 'A')
C *** SUBROUTINE READ_POPLA_SOD 
C     PRODUCES TWO SETS OF REGULARLY SPACED AND ONE SET OF RANDOMLY
C     DISTRIBUTED EULER ANGLES WITH WEIGHTS (BUNGE NOTATION) STARTING
C     FROM A popLA *.SOD INTENSITY FILE (IFORMAT=0)
C     IT CAN ALSO HANDLE ODF FILES GENERATED BY BEARTEX SOFTWARE
C     (IFORMAT=1) AND BY EBSD SOFTWARE (IFORMAT=2)
C *** SUBROUTINE CHAOS 
C     ASSIGNS WEIGHTS TO A RANDOM DISTRIBUTION OF ORIENTATIONS IN ORDER
C     TO REPRODUCE THE TEXTURE READ FROM AN ODF FILE.
C *** SUBROUTINE TEXTURE 
C     ACTIVATE ISKIP=0 FOR CREATING REDUCED_TEXTURE.TEX FILE
c ***********************************************************************
c ***     INPUT FILES:                                                ***
c ***        unit 1 (ur1):  pole8.in                                  ***
c ***        unit 2 (ur2):  texture file(s)                           ***
c ***        unit 3 (ur3):  pole8.pro                                 ***
c ***        unit 7 (ur4):  single crystal file 'filecrys'            ***
c ***********************************************************************
c ***     OUTPUT FILES:                                               ***
c ***        unit  4 (uw2): discriminated texture file(s)             ***
c ***        unit  8 (uw8): texture factors and statistics            ***
c ***        unit 10 (uw1): POLE8.OUT                                 ***
c ***     Level lines option:                                         ***
c ***        unit 11 :  circles coordinates (2 lines in subr circle)  ***
c ***        unit 12 :  crosses coordinates (2 lines in subr isolev)  ***
c ***        unit 13 :  maxima & their coordinates (1 line in isolev) ***
c ***        unit 14 :  labels & their coordinates (2 lines in circle)
c ***        unit 17 :  GRID_VF.DAT (pole vol fract at grid positions)
c ***        unit 18 :  PROFILE.DAT (only for axysymmetry option)     ***
c ***        unit 19 :  GRID_INT.DAT (intensity at grid positions)    ***
c ***        unit 20 :  PF_DIFF.DAT (Pole Fig Difference parameter)   ***
c ***        unit 21-36:   level lines coordinates                    ***
c ***     Dots option:                                                ***
c ***        unit 21-30:   coordinates of crosses binned by weight    ***
c ***        unit 777: REDUCED_TEXTURE.TEX
c ***********************************************************************
c *** ASCI characters and associated number:                          ***
c       32: blank space                                               ***
c       40: (   41: )   42: *   43: +   44: ,   45: -   46: .   47: / ***
c       48: 0   49: 1   50: 2   51: 3   52: 4   .............   57: 9 ***
c       58: :   59: ;   60: <   61: =   62: >                         ***
c ***********************************************************************
      IMPLICIT NONE 
	  
      include 'pole8.dim'
	  
      character      nfile*20 , filecrys*80 , prosa*80
      character*10   time,date,zone
      character*1    backsl
      character*1000 tmp1
	  
      double precision a0,a1,a2,avf,binsize,cos1,cubicfactor
      double precision deltx,delty,deltz,hdeltx
      double precision fphi,fthe,fome,fvfr,fpole,fcomp,fnorm
      double precision pfdif,pfrot,phibot,phitop
      double precision phidx, seca, smthfr, sn, sb, sneq
      double precision pro, rad, radx, scale, rcomp, spread, spreadr
      double precision sum1, sum2, tiny, twgt, vfacc, w1, wgtmax
      double precision thx, thex, thetax
      double precision x1, y1, z1, xaux, yaux, xptop, xpbot, xpx, ypx
      double precision xori, yori, xframe, yframe, xsepa, ysepa
      double precision xsize, ysize,ipfx(3),ipfy(3)
      double precision zero, cutoff, abs_intensity,total_pf_wgt
  
	  
      integer  dt(8),i,j,k,l,ibin,icrysym,igrain,ip,ipfigx,ipp
      integer  ifilter,ips,isb,isn,ishft,ismth,iunit,jp,jpol,ix,jx
      integer  mbot,mtop,ntop,nbot,ncmax,ncmaxx,ncols,nrows
      integer  meven,mp1,np1,mh,mhp1,mhp2,npacum,mp2,np2
      integer  ndifpoles, ndifpol, ndiftexts, ndiftex, npepf,ipfxx
      integer  ngrain, ninputfiles, nlines, ntfpf, ngrtf
      integer  nloops, np, npbin, npol, nps, npx, nxx, nyy
      integer  polx, sign, ithe, jphi, plines, plmax
      integer  colpol
      integer  default
	        
      dimension    isn(4),sn(3),sneq(3,24),isb(4),sb(3)
      dimension    rcomp(3),fcomp(3)
      dimension    fphi(0:75),fthe(20),fvfr(20,74,6,6)
      dimension    xpx(npmax),ypx(npmax),npbin(10)
      character*4  ipfC(10)
      character*6  ipfH(20)
      dimension    ntfpf(maxt),ngrtf(maxt,maxt)
      logical      xlgnu, xdgnu

c ****** for gnuplot-based plotting by Arul - START      
      parameter(backsl='\\') 	  
      common /gnuplot/ plines, plmax
c ****** for gnuplot-based plotting by Arul - END

      prosa=prosa      ! to fool the compiler
      dash = '         '

c *******************************************************************

      ur1=1
      ur2=2
      ur3=3
      ur4=7
      uw1=10
      uw2=4
      uw8=8     

      xlgnu = .false.
      xdgnu = .true.
      plines= 1
      plmax = 0
      
      open(ur1,file='pole8.in',status='old')

      open(uw1,file='POLE8.OUT',status='unknown')

      write(*,*) 'enter identification of output file (5 characters)'
      write(*,*)
      read (*,'(a5)')   outfileid
      write(uw1,'(a5)') outfileid

c *** reads path & name of texture files

      read(ur1,'(a)') prosa
      read(ur1,*)     ninputfiles
      read(ur1,'(a)') prosa
      do i=1,ninputfiles
        read(ur1,'(a)') inputfile(i)
      enddo

c *** read parameter 'ipfig', indicating the type of plot:
c     0 for PF plot, 1 for IPF plot, -1 for popLA *.sod, -2 for popLA.epf

      read(ur1,'(a)') prosa
      read(ur1,*)     ipfig

      if(ipfig.eq.-2) nind=3

      if (ipfig.ge.-1) then

c *** reads path & name of file with single crystal symmetry & parameters.
c     calls CRYSTAL_SYMMETRY to read unit cell parameters and to generate
c     unit cell vectors and symmetry operations associated with ICRYSYM.

        read(ur1,'(a)') prosa
        read(ur1,'(a)') filecrys
        open(unit=ur4,file=filecrys,status='old')
          call crystal_symmetry (1,ur4,icrysym,isn,sn,sneq,isb,sb,npol)
        close(unit=ur4)

c *** reads Miller indices of poles (or sample axes if IPF) to be plot.
c     for hexag & trigonal reads 4 indices.

        nind=3
        if (icrysym.eq.2 .or. icrysym.eq.3) nind=4
        if (ipfig.gt.0) nind=3

        read(ur1,'(a)') prosa
        read(ur1,*)     ndifpoles
        if(ndifpoles.gt.maxp) then
          write(*,'('' TOTAL NUMBER OF POLES CANNOT EXCEED'',i4)') maxp
          write(*,'('' >  WILL PLOT ONLY FIRST'',i4,'' POLES'')') maxp
          ndifpoles=maxp
c          pause
        endif
        read(ur1,'(a)') prosa
        do jpol=1,ndifpoles
          read(ur1,*) (miller(i,jpol),i=1,nind)
        enddo

      endif      ! end of loop for ipfig.ge.-1

      close(unit=ur1)

c **********************************************************************
c     opens some output files for this run
c **********************************************************************

      nfile=outfileid//'_CC.DAT'
        open (unit=11,file=nfile,status='unknown')
      nfile=outfileid//'_XX.DAT'
        open (unit=12,file=nfile,status='unknown')
      nfile=outfileid//'_MX.DAT'
        open (unit=13,file=nfile,status='unknown')
      nfile=outfileid//'_LB.DAT'
        open (unit=14,file=nfile,status='unknown')

c ****** for gnuplot-based plotting by Arul - START
        nfile=outfileid//'.plt'
        open (unit=9,file=nfile,status='unknown')  
        write(9, *)'# GNUPLOT program to plot the output of POLE8.FOR'
        write(9, *)'# POLE8d developed by C. N. Tome'
        write(9, *)'# modified for GNUPLOT capability by Arul Kumar'

        write(9, *) 'set noborder'
        write(9, *) 'set size ratio -1'
        write(9, *) 'set key outside'
        write(9, *) 'set noxtics'
        write(9, *) 'set noytics'
        
        nfile=outfileid//'.p'
        open (unit=99,file=nfile,status='unknown')  
c ****** for gnuplot-based plotting by Arul - END

c **********************************************************************
c     initialize default settings for representing PF's and IPF's
c **********************************************************************

c *** For IPS's 'mgrid' has to be a multiple of 12, or 8, or 6 or 4, or 2
c *** depending on ICRYSYM. For EPF files the input grid is fix at 72x18.
      mgrid=36
      ngrid= 9
      if(ipfig.gt.0 .or. ipfig.eq.-2) then
        mgrid=72
        ngrid=18
      endif
      spread=180.001/mgrid
      icros= 0
      ifull= 0
      igrid= 0
      iproj= 0
      irepr= 0
      isepa= 0
      step = 0.5
      ishft= 0
      ismth= 0
      isym = 0
      pfrot= 0.
      ncmax= 6      ! maximum number of columns per row
      iper(1)=1
      iper(2)=2
      iper(3)=3

      pf_wgt_factor=1.      ! added 11/01/2017

      write(*,*) 'enter: '
      write(*,*) '   1 if you want to choose the settings'
      write(*,*) '   0 if you want to use default settings'
      write(*,*) '  -1 to read settings from pole8.pro  ---> '
      read (*,*)  default

c **************************************************************************
c *** opens one or several input files 'ninputfiles', each containing one
c *** or several popLA measured pole intensities.
c *** splits those into 'ndifpoles' single intensity files 'POLE_nn.DAT'
c **************************************************************************

      if(ipfig.eq.-2) then
        default=0
        ndiftexts=1
        call read_popla_epf (ninputfiles,ndifpoles,
     #                       mp2,np2,ntop,mbot,mtop)
        go to 888
      endif
	  	  
c **************************************************************************
c *** opens one 'inputfile' containing intensities of the Orientation
c     Distribution Function, for regularly spaced Euler angles, in popLA
c     format *.SOD
c *** Creates three discrete texture files: *.FUL, *.RED, *.RAN ('*' stands
c     for 'outfileid'). Plots the poles read from pole8.in for the 3 files.
c **************************************************************************

      if(ipfig.eq.-1) then
        call read_popla_sod (inputfile(1),outfileid,icrysym,
     #                       default,ur2,uw2)
        ninputfiles=3
        inputfile(1)=outfileid//'.FUL'
        inputfile(2)=outfileid//'.RAN'
        inputfile(3)=outfileid//'.RED'
        ipfig=0      ! will plot direct pole figs by default
      endif

c **************************************************************************
c *** opens one or several input files 'ninputfiles', each containing one
c *** or several discrete textures
c *** Splits those into 'ndiftexts' single texture files 'TEXT_nn.DAT'
c **************************************************************************

      if(ipfig.ge.0) then
        nfile=outfileid//'_text_facts.dat'
        open(uw8,file=nfile,status='unknown')

        call read_texture_files (ninputfiles,ndiftexts,ntfpf,ngrtf)
      endif

c **********************************************************************
      if (default.eq.-1) then
        open(ur3,file='pole8.pro',status='old')

c *** general parameters associated with dot & line PF's
        read(ur3,'(a)') prosa
        read(ur3,*)     ifull,iproj,irepr,isym,ncmax
        read(ur3,'(a)') prosa
        read(ur3,*)     iper(1),iper(2),iper(3)
c *** parameters associated with grid & line
        read(ur3,'(a)') prosa
        read(ur3,*)     igrid,mgrid,ngrid
c *** parameters associated with PF massaging
        read(ur3,'(a)') prosa
        read(ur3,*)     ishft,ismth,pfrot
        pfrot=pfrot*pi/180.
c *** parameters associated with line representation (defined in ISOLEV)
        read(ur3,'(a)') prosa
        read(ur3,*)     icros,isepa,spread
        read(ur3,'(a)') prosa
        read(ur3,*)     nlevels
          if(nlevels.gt.nlmax) then
            write(*,*) '*** nlevels EXCEEDS MAXIMUM DIMENSION nlmax'
            stop
          endif
        read(ur3,'(a)') prosa
        read(ur3,*)     (rlevel(l),l=1,nlevels)
        do l=1,nlevels
          level(l)=l
        enddo

        close(unit=ur3)
      endif

c **********************************************************************
      if(default.ne.-1 .and. ipfig.eq.0) then
        write(*,*)
        write(*,*) 'enter indices of pole figure axes:'
        write(*,*) '   right,top,center                ---> '
        read (*,*)  iper(1),iper(2),iper(3)

        write(*,*) 'choose an option of symmetrization:'
        write(*,*) '   no symmetry  (0)'
        write(*,*) '   2-fold axis  (1)'
        write(*,*) '   x-mirror     (2)'
        write(*,*) '   y-mirror     (3)'
        write(*,*) '   x&y-mirror   (4)'
        write(*,*) '   axisymmetry (-1)                ---> '
        read(*,*) isym
        if(isym.gt.0) then
          write(*,*) 'enter (0) for a full circle representation'
          write(*,*) 'enter (1) for a reduced circular section   ---> '
          read (*,*)  ifull
        endif
      endif
c *********************************************************************
      if(default.eq.1) then
        write(*,*) 'choose equal area projection (0)'
        write(*,*) 'or stereographic projection  (1) ---> '
        read (*,*)  iproj

        write(*,*) 'choose level lines (0)'
        write(*,*) 'or dots representation (1)    ---> '
        read (*,*)  irepr
        if(irepr.eq.1 .and. isym.eq.-1) isym=0

        write(*,*) 'enter PF rotation in degrees  ---> '
        read (*,*)  pfrot
        pfrot=pfrot*pi/180.
      endif

      if(default.eq.1 .and. irepr.eq.0) then
        write(*,*) 'choose type of grid:'
        write(*,*) '  equispaced in phi , theta         (0)'
        write(*,*) '  or equispaced in phi , cos(theta) (1)  ---> '
        read (*,*)  igrid

        write(*,*) 'smooth polar sector of Pole Figure ?'
        write(*,*) 'enter (0) if not'
        write(*,*) 'enter 1<ismth<10 for weak/strong smoothing ---> '
        read (*,*)  ismth
      endif

      if(default.eq.1 .and. irepr.eq.0 .and. ipfig.eq.0) then
        write(*,*) 'enter number of cells MGRID,NGRID (maximum 72x18)'
        write(*,*) 'in range: phi=[0,2*pi] & theta=[0,pi/2]    --->  '
        read(*,*) mgrid,ngrid

        if(isym.lt.4) meven=(mgrid/2)*2
        if(isym.eq.4) meven=(mgrid/4)*4
        if((mgrid/meven)*meven .ne. mgrid) then
          mgrid=(mgrid/meven)*meven
          write(*,'(''*** because of boundary condition requirements '',
     #              ''mgrid is updated to'',i3)') mgrid
        endif

        write(*,*) 'shift grid by deltaphi/2 (1) or not (0)?   ---> '
        read (*,*)  ishft
        if(ishft.eq.1) isym=0
      endif

c **********************************************************************
c *** defines the coordinates of the grid x=phi , y=cos(theta) , z=theta

      if(irepr.eq.0) then

        np2=ngrid+2
        mp2=mgrid+2
        deltx=2.*pi/mgrid
        hdeltx=deltx/2.*ishft
        do j=1,mp2
          x(j)=-pi+(j-1.5)*deltx-hdeltx
        enddo

c *** defines a grid with (mgrid*ngrid+1) equal-area spherical elements.
        if(igrid.eq.1) then
          delty=mgrid/(mgrid*ngrid+1.)
          cos1=ngrid*delty
          y(1)=0.9999      !set interp point as close to pole as possible
          z(0)=0.
          z(1)=acos(cos1)
          do i=2,np2
            y(i)=cos1-(i-1.5)*delty
            z(i)=acos(cos1-(i-1)*delty)
          enddo
        endif

c *** defines a grid of mgrid*ngrid spherical elements spanning equal angles
c *** plus a polar cup spanning z(1) degrees.
        if(igrid.eq.0) then
          y(1)=0.9999         !set interp point as close to pole as possible
          z(0)=0.
          z(1)=(pi/180.)*5    ! hardwires a 5 deg polar cap if igrid=0
          if(ipfig.gt.0) z(1)=pi/2./ngrid
          deltz=(pi/2.-z(1))/float(ngrid)
          do i=2,np2
            z(i)=z(1)+(i-1.)*deltz
            y(i)=(cos(z(i))+cos(z(i-1)))/2.
          enddo
        endif

c *** generates a 'cluster' of poles around each pole if spread>0
        if(default.eq.0) spread=180.001/mgrid
        if(default.eq.1) then
          spread=180.001/mgrid
          write(*,'('' suggested spread is'',f5.1,'' deg'')') spread
          write(*,*) 'enter (0) if you do not want to spread the poles'
          write(*,*) 'or enter spread around poles in degrees    ---> '
          read (*,*)  spread
        endif
        nps=1
        frac(1)=1.d0
        spreadr=spread*pi/180.d0
        if(spread.gt.0) call spread_poles(1,spreadr,nps,x1,y1)

      endif

  888 continue      ! skips all previous when ipfig=-2

c **********************************************************************
c *** Scales radious (in inches) of PF or IPF consistent with the number
c     of different poles and texture files.
c     For cubic IPF calculates extra factor to expand IPF to radious size.

      cubicfactor=1.
      if(icrysym.eq.1 .and. ipfig.gt.0) then
        xaux=0.
        yaux=cos(45./180.*pi)
        call project(xaux,yaux,1.d0,iproj)
        cubicfactor=1./xaux
      endif

      xframe=6.5      ! drawing area in inches
      yframe=6.5

c *** default is to enforce more columns than rows
      ncols=max(ndifpoles,ndiftexts)
      nrows=min(ndifpoles,ndiftexts)

c ****** for gnuplot-based plotting by Arul - START
      if (ndifpoles.ge.ndiftexts) then
         colpol = 1
      else
         colpol = 0
      endif
c ****** for gnuplot-based plotting by Arul - END
     
c *** enforces more rows than columns (26/mar/07)
c     nrows=max(ndifpoles,ndiftexts)
c     ncols=min(ndifpoles,ndiftexts)

c *** when plotting EPF's the same poles are repeated in 'ninputfiles'
      if(ipfig.eq.-2) then
        ncols=ndifpoles/ninputfiles
        nrows=ninputfiles
c     for gunplot based plotting by Arul - START
        colpol = 1
c     for gunplot based plotting by Arul - END
      endif

c *** alternative option for controling maximum number of columns 'ncmax'.
c *** ncmaxx= 0 will enforce the default
c *** setting ncmax= # will hardwire the # of columns in the plot

      ncmaxx = 0
c     added by Arul
      if(ncols.le.ncmax) ncmaxx=0
      if(ncols.gt.ncmax) then
        if(default.gt.0) then
          write(*,'('' intends to plot'',i3,'' PFs per row'')') ncols
          write(*,*) ' enter # of PFs per row that you want to plot -> '
          read (*,*) ncmax
        endif

c      the following two lines commented by Arul
c        ncmaxx=ncmax
c        ncols =ncmax

c        nrows= ((ndiftexts-1)/ncmax + 1) * ndifpoles
        if(nrows.gt.6) then
          write(*,*) 'will plot more than 6 PFs per column'
c          pause
        endif
      endif
      write(*,*) ncols, nrows

      if(ipfig.le.0) then
        rad=1.0
        xsepa=2.4*rad
        ysepa=2.7*rad
        if(ifull.eq.1) then
          if(isym.le.2) xsepa=1.4*rad
          if(isym.ge.3) ysepa=1.7*rad
          if(isym.eq.4) xsepa=1.4*rad
        endif
      else if(ipfig.gt.0) then
        rad=1.5
        xsepa=1.4*rad
        ysepa=1.7*rad
        if(icrysym.eq.6 .or. icrysym.eq.7) then
          rad=1.0
          xsepa=2.4*rad
          ysepa=2.7*rad
        endif
      endif

      xsize=ncols*xsepa
      ysize=nrows*ysepa
      scale=min(rad,xframe/xsize,yframe/ysize)
      rad  =scale*rad
      radx =rad*cubicfactor   ! accounts for IPFs of cubics
      xsepa=scale*xsepa
      ysepa=scale*ysepa

c *** subroutine CIRCLES generates the points of the circular section,
c     defines labels and label coordinates.

      call circles (xori,yori,1.D0,radx,icrysym,1)

c **********************************************************************
c *** Write heading with information about this run in file POLE8.OUT

      call date_and_time (date,time,zone,dt)
      date=date
      time=time
      zone=zone
      nlines=7+ninputfiles
      write(uw1,'(i4,''   next lines in POLE8.OUT is text'')') nlines
      write(uw1,'(i4,''/'',i2,''/'',i2,2x,i2,'':'',i2)')
     #                   dt(1),dt(2),dt(3),dt(5),dt(6)
      do ix=1,ninputfiles
        if(ipfig.ge.0) then
          write(uw1,'(a50,16i5)') inputfile(ix),
     #                           (ngrtf(ix,jx),jx=1,ntfpf(ix))
        else
          write(uw1,'(a80)') inputfile(ix)
        endif
      enddo

      if(icrysym.eq.0) write(uw1,'(''* ????? crystal'')')
      if(icrysym.eq.1) write(uw1,'(''* CUBIC crystal'')')
      if(icrysym.eq.2) write(uw1,'(''* HEXAGONAL crystal'')')
      if(icrysym.eq.3) write(uw1,'(''* TRIGONAL crystal'')')
      if(icrysym.eq.4) write(uw1,'(''* TETRAGONAL crystal'')')
      if(icrysym.eq.5) write(uw1,'(''* ORTHOGONAL crystal'')')
      if(icrysym.eq.6) write(uw1,'(''* MONOCLINIC crystal'')')
      if(icrysym.eq.7) write(uw1,'(''* TRICLINIC crystal'')')

      if(ipfig.eq.-2) then
        write(uw1,*) '* popLA EPF file'
      else if(ipfig.eq.0) then
        if(isym.eq.0)  write(uw1,*) '* PF not symmetrized'
        if(isym.eq.1)  write(uw1,*) '* two-fold PF symmetry'
        if(isym.eq.2)  write(uw1,*) '* x-mirror PF symmetry'
        if(isym.eq.3)  write(uw1,*) '* y-mirror PF symmetry'
        if(isym.eq.4)  write(uw1,*) '* orthogonal PF symmetry'
        if(isym.eq.-1) write(uw1,*) '* axial PF symmetry'
      else if(ipfig.gt.0) then
        write(uw1,*)               '* inverse pole figure'
      endif

      if(iproj.eq.0) write(uw1,*) '* equal area projectn'
      if(iproj.eq.1) write(uw1,*) '* stereograph projectn'

      if(irepr.eq.0) then
        if(igrid.eq.0) write(uw1,'(''*'',i3,''x'',i2,
     #                         '' [phi,th] grid'')') mgrid,ngrid
        if(igrid.eq.1) write(uw1,'(''*'',i3,''x'',i2,
     #                         '' [phi,cos(th)] grid'')') mgrid,ngrid
        write(uw1,'(''*'',f5.1,'' degrees spread'')') spread
        write(uw1,'(''* center smoothing='',i2)') ismth
        write(uw1,'(i2,'' (line representation)'')')  irepr
      else if(irepr.eq.1) then
        write(uw1,*)
        write(uw1,*)
        write(uw1,*)
        write(uw1,'(i2,'' (dot representation)'')')  irepr
      endif

      write(uw1,'(f6.2,'' (pole figure radious)'')') rad
      write(uw1,'(i2,'' (pole figure symmetrization)'')') isym*ifull
      ipfigx=ipfig
      if(ipfig.eq.-2) ipfigx=0
      if(ipfig.le.0) write(uw1,'(i2,'' (direct pole figure)'')') ipfigx
      if(ipfig.gt.0) write(uw1,'(i2,'' (invers pole figure)'')') ipfigx
      write(uw1,*)
      write(uw1,'(2i5,''  npoles,ntextures'')') ndifpoles,ndiftexts

c **********************************************************************
c *** For direct pole figures uses the indices of the pole to be
c     represented, plus crystal symmetry operations, to calculate the
c     'npol' crystall. equiv. poles and normal vectors 'sneq(3,npol)'
c *** For inverse pole figures uses the indices of the sample axis
c     to be represented, plus crystal symmetry operations, to calculate
c     equivalent 'pseudopoles' sneq(3,npol)
c *** For popLA *.epf files reads a function associated with a grid.
c **********************************************************************

      nloops=0

      do 300 ndifpol=1,ndifpoles     ! LOOP OVER SEVERAL POLES

        do i=1,nind
          isn(i)=miller(i,ndifpol)
          isnlbl(i)=miller(i,ndifpol)
        enddo

        if(ipfig.eq.-2) then
          open(ur2,file=polefile(ndifpol),status='old')
          read(ur2,*) prosa
          read(ur2,*) ((f(i,j),j=1,mp2),i=1,ntop)
          close(unit=ur2)
        endif

        if(ipfig.eq.0) then
          call crystal_symmetry (2,ur1,icrysym,isn,sn,sneq,isb,sb,npol)
          call crystal_symmetry (3,ur1,icrysym,isn,sn,sneq,isb,sb,npol)
        else if(ipfig.gt.0) then
          if((isn(1)**2+isn(2)**2+isn(3)**2).ne.1) then
            write(*,*) ' can only plot IPF of sample axes !!'
            stop
          endif
          if(isn(1).eq.1) ipfig=1
          if(isn(2).eq.1) ipfig=2
          if(isn(3).eq.1) ipfig=3
        endif

      do 290 ndiftex=1,ndiftexts     ! LOOP OVER SEVERAL TEXTURES

ccc     pfrot=0.                             ! temporary special case
ccc     if(ndiftex.eq.1) pfrot=90.*pi/180.   ! temporary special case

        nloops=nloops+1
        if(nloops.ge.2) default=-1

        if(ipfig.ge.0) then
          open(ur2,file=textfile(ndiftex),status='old')
            call texture (ngrain,ndifpol,ndiftex)
          close(unit=ur2)
        endif

c *** defines the position of the (0,0) point of PF's and IPF's depending
c     on # of textures, # of PF's, and symmetrization option chosen.
        
        if(ndifpoles.ge.ndiftexts) then
          nxx=ndifpol
          nyy=ndiftex
          polX = 1
        else if(ndifpoles.lt.ndiftexts) then
          nxx=ndiftex
          nyy=ndifpol
          polX = 0
        endif

        if(ipfig.eq.-2) then
          npepf=ndifpoles/ninputfiles
          nxx=nloops-(nloops-1)/npepf*npepf
          nyy=       (nloops-1)/npepf + 1
        endif

c *** alternative algorithm for forcing ncmax columns
        if(ncmaxx.gt.0) then
          nxx= nloops -(nloops -1)/ncmax*ncmax
          nyy= (nloops-1)/ncmax + 1
        endif
        
        xori= xsepa*(nxx-1)
        yori=-ysepa*(nyy-1)
        
c       write(*,*) nxx, nyy, colpol, nind, ndiftex, ndiftexts

c ****** for gnuplot-based plotting by Arul - START

       if(ipfig.le.0) then
          
          if (colpol.eq.1) then
c             if (ndiftex.eq.1) then
             if (nyy.eq.1) then
               if (nind.eq.3) then                     
         write(9,'(''set label "('',3i2,'' )" at'', F6.2,'','' ,F6.2)') 
     $         (miller(i,ndifpol),i=1,nind), xori-0.3, yori+radx+0.2
                else
         write(9,'(''set label "('',4i2,'' )" at'', F6.2,'','' ,F6.2)') 
     $         (miller(i,ndifpol),i=1,nind), xori-0.3, yori+radx+0.2 
                endif
             endif
          else
             if (nxx.eq.1) then
c             if (ndiftex.eq.1) then
                if (nind.eq.3) then  
         write(9,'(''set label "('',3i2,'' )" at'', F6.2,'','' ,F6.2)') 
     $         (miller(i,ndifpol),i=1,nind), xori-radx-0.5, yori
                else
          write(9,'(''set label "('',4i2,'' )" at'', F6.2,'','' ,F6.2)') 
     $         (miller(i,ndifpol),i=1,nind), xori-radx-0.5, yori 
                endif
             endif
          endif
         
          if (ndifpol.eq.ndifpoles) then
             if (ndiftex.eq.ndiftexts) then
             write(9,'(''set label "'',i2,''" at'', F6.2,'','' ,F6.2)') 
     $         iper(1), xori+radx, yori
             write(9,'(''set label "'',i2,''" at'', F6.2,'','' ,F6.2)') 
     $         iper(2), xori-0.06, yori+radx+0.1        
             endif
           endif
       
        endif
      
c ****** for gnuplot-based plotting by Arul - END
    
      if(ipfig.gt.0) then
        if(icrysym.eq.1) then
          ipfC(1)='001'
          ipfC(2)='110'
          ipfC(3)='111'         
        elseif(icrysym.eq.2) then
           ipfH(1)='0001'
           ipfH(2)='2110'
           ipfH(3)='1010'
        elseif(icrysym.eq.3) then
           ipfH(1)='0001'
           ipfH(2)='2110'
           ipfH(3)='1120'
        elseif(icrysym.eq.4) then
           ipfC(1)='111'
           ipfC(2)='100'
           ipfC(3)='110'
        elseif(icrysym.eq.5) then
           ipfC(1)='111'
           ipfC(2)='100'
           ipfC(3)='010'
        endif
      end if

c  *** Write information about this loop in file POLE8.OUT
      if(ipfig.le.0) write(uw1,'(4i3,''     poles'')')
     #                    (miller(i,ndifpol),i=1,nind)
      if(ipfig.gt.0) write(uw1,'(3i3,''     sample axis'')')
     #                    (miller(i,ndifpol),i=1,3)

c *** Subroutine CIRCLES writes the coordinates of the circular section
c *** into files 'POLE8.OUT' and 'FILEID_CC.DAT'.
c *** Writes the coordinates of the labels into 'FILEID_LB.DAT'.

      call circles (xori,yori,rad,radx,icrysym,2)


c ****** for gnuplot-based plotting by Arul - START

      if(ipfig.gt.0) then
         
          open(94,file='polec.p', status='old')          

        if (ndifpol.eq.ndifpoles) then
           if (ndiftex.eq.ndiftexts) then
              read(94,*) ipfx(1), ipfy(1)
              read(94,*) ipfx(2), ipfy(2)
              read(94,*) ipfx(3), ipfy(3)           
c 
              if ( (icrysym.eq.2).or.(icrysym.eq.3) )  then
         write(9,'(''set label "('',a4,'')" at'', F6.2,'','' ,F6.2)') 
     $         ipfH(1), ipfx(1),ipfy(1)-0.05
         write(9,'(''set label "('',a4,'')" at'', F6.2,'','' ,F6.2)') 
     $         ipfH(2), ipfx(2),ipfy(2)-0.05
         write(9,'(''set label "('',a4,'')" at'', F6.2,'','' ,F6.2)') 
     $         ipfH(3),ipfx(3),ipfy(3)
        else
         write(9,'(''set label "('',a3,'')" at'', F6.2,'','' ,F6.2)') 
     $         ipfC(1), ipfx(1),ipfy(1)-0.05
         write(9,'(''set label "('',a3,'')" at'', F6.2,'','' ,F6.2)') 
     $         ipfC(2), ipfx(2),ipfy(2)-0.05
         write(9,'(''set label "('',a3,'')" at'', F6.2,'','' ,F6.2)') 
     $         ipfC(3), ipfx(3),ipfy(3)
        endif   
      endif
      endif



      if (colpol.eq.1) then
         if (nyy.eq.1) then
            if ( (icrysym.eq.2).or.(icrysym.eq.3) )  then
         write(9,'(''set label "('',3i1,'')" at'', F6.2,'','' ,F6.2)') 
     $      (miller(i,ndifpol),i=1,3), xori+(radx/3), yori+(radx/2)+0.2
            else
         write(9,'(''set label "('',3i1,'')" at'', F6.2,'','' ,F6.2)') 
     $      (miller(i,ndifpol),i=1,3), xori+(radx/3), yori+(radx/2)+0.2
            endif  
         endif
      else
         if (nxx.eq.1) then
           if ( (icrysym.eq.2).or.(icrysym.eq.3) )  then
         write(9,'(''set label "('',3i1,'')" at'', F6.2,'','' ,F6.2)') 
     $         (miller(i,ndifpol),i=1,3), xori, yori+(radx/4)
            else
         write(9,'(''set label "('',3i1,'')" at'', F6.2,'','' ,F6.2)') 
     $         (miller(i,ndifpol),i=1,3), xori, yori+(radx/4)
            endif 
         endif
      endif


      close(unit=94, status='delete')
c ****** for gnuplot-based plotting by Arul - END

      endif

c *** Write information about this loop in file POLE8.OUT
c      if(ipfig.le.0) write(uw1,'(4i3,''     poles'')')
c     #                    (miller(i,ndifpol),i=1,nind)
c      if(ipfig.gt.0) write(uw1,'(3i3,''     sample axis'')')
c     #                    (miller(i,ndifpol),i=1,3)

c *** Subroutine CIRCLES writes the coordinates of the circular section
c *** into files 'POLE8.OUT' and 'FILEID_CC.DAT'.
c *** Writes the coordinates of the labels into 'FILEID_LB.DAT'.

c      call circles (xori,yori,rad,radx,icrysym,2)

      if(ipfig.eq.-2) go to 280   ! define circles & skip the rest for EPF plot

c **************************************************************************
c *** calculates coordinates of polar vectors: xp=phi,yp=cos(theta),zp=theta
c **************************************************************************

      if(ipfig.le.0) then
        npx=npol*ngrain
        if(isym.le.0) npx=npx
        if(isym.eq.1.or.isym.eq.2.or.isym.eq.3) npx=2*npx
        if(isym.eq.4) npx=4*npx
      elseif(ipfig.ge.1) then
        if(icrysym.eq.1) npx=24*ngrain
        if(icrysym.eq.2) npx=12*ngrain
        if(icrysym.eq.3) npx= 6*ngrain
        if(icrysym.eq.4) npx= 8*ngrain
        if(icrysym.eq.5) npx= 4*ngrain
        if(icrysym.eq.6) npx= 2*ngrain
        if(icrysym.eq.7) npx= 1*ngrain
      endif

      if(npx .gt. npmax) then
        write(*,*) '**** DIMENSION npmax =  ',npmax,'  EXCEEDED'
        write(*,*) '**** INCREASE  npmax TO ',npx,'    IN POLE8.DIM'
        stop
      endif

      np=1
      twgt=0.0     
      do igrain=1,ngrain
        twgt=twgt+wgt(igrain)

c *** when plotting IPF's calculates the 'npol' sneq for each orientation by
c *** applying the symmetry operations to sample axis 'ipfig' being plotted
c *** (given by the corresponding column of the grain's rotation matrix)

        if(ipfig.gt.0) then
          do i=1,3
            sn(i)=r(i,ipfig,igrain)
          enddo
          call crystal_symmetry (3,ur1,icrysym,isn,sn,sneq,isb,sb,npol)
        endif

        do k=1,npol

          if(ipfig.eq.0) then
            do j=1,3
            rcomp(j)=0.
              do i=1,3
                rcomp(j)=rcomp(j)+r(i,j,igrain)*sneq(i,k)
              enddo
            enddo
          else if(ipfig.gt.0) then
            do j=1,3
              rcomp(j)=sneq(j,k)
            enddo
          endif

c *** accounts for axes permutation in pole figure representation,
c *** including negative axis directions.
          fcomp(1)=isign(1,iper(1))*rcomp(abs(iper(1)))
          fcomp(2)=isign(1,iper(2))*rcomp(abs(iper(2)))
          fcomp(3)=isign(1,iper(3))*rcomp(abs(iper(3)))

          if(fcomp(3).lt.0.0) then
            fcomp(1)=-fcomp(1)
            fcomp(2)=-fcomp(2)
            fcomp(3)=-fcomp(3)
          endif

          seca=sqrt(fcomp(1)**2+fcomp(2)**2)
          if(seca.lt.1.e-03) then
            xp(np)=0.0 +pfrot
            yp(np)=cos(seca)
          else
            xp(np)=atan2(fcomp(2),fcomp(1)) +pfrot
            yp(np)=fcomp(3)
          endif
          wgtp(np)=wgt(igrain)
          np=np+1

        enddo      ! end of DO K=1,NPOL
      enddo      ! end of DO GRAIN=1,NGRAIN
      np=np-1

c *** symmetrizes the poles according to the value of 'isym'

c *** performs a center inversion.
      if(isym.eq.1) then
        do ip=1,np
          sign=1
          if(xp(ip).gt.0.0) sign=-1.
          xp(ip+np)=sign*(pi-abs(xp(ip)))
          yp(ip+np)= yp(ip)
          wgtp(ip+np)=wgtp(ip)
        enddo
        np=2*np
        twgt=2.*twgt
      endif

c *** performs an x-axis inversion.
      if(isym.eq.2 .or. isym.eq.4) then
        do ip=1,np
          if(xp(ip).ge.0.0) xp(ip+np)= pi-xp(ip)
          if(xp(ip).lt.0.0) xp(ip+np)=-pi-xp(ip)
          yp(ip+np)= yp(ip)
          wgtp(ip+np)=wgtp(ip)
        enddo
        np=2*np
        twgt=2.*twgt
      endif

c *** performs a y-axis inversion.
      if(isym.eq.3 .or. isym.eq.4) then
        do ip=1,np
          xp(ip+np)=-xp(ip)
          yp(ip+np)= yp(ip)
          wgtp(ip+np)=wgtp(ip)
        enddo
        np=2*np
        twgt=2.*twgt
      endif

      if(np.gt.npmax) then
        write(*,'('' maximum # of poles exceeded'')')
        write(*,'('' np='',i11,''  npmax='',i11)') np,npmax
c        pause
      endif

c *********************************************************************
c     BLOCK FOR PROCESSING POINT POLE FIGURES (irepr=1)

      if(irepr.eq.1) then
c *********************************************************************

c *** keeps only the poles that are in the reduced symmetry region
c *** associated with isym=1,2,3,4.

        if(isym.ne.0 .and. ifull.gt.0) then

          if(isym.eq.1 .or. isym.eq.2) then
            xpbot=-pi/2.
            xptop= pi/2.
          else if (isym.eq.3) then
            xpbot= 0.
            xptop= pi
          else if (isym.eq.4) then
            xpbot= 0.
            xptop= pi/2.
          endif

          ipp=0
          do ip=1,np
            if(xp(ip).ge.xpbot .and. xp(ip).le.xptop) then
              ipp=ipp+1
              xp(ipp)=xp(ip)
              yp(ipp)=yp(ip)
              wgtp(ipp)=wgtp(ip)
            endif
          enddo
          np=ipp

        endif      ! end of if(isym.ne.0)

c ***************************************************************************
c *** projects each pole and stores the coordinates of the projection
c *** plus an integer proportional to the weight.

c *** for inverse pole figures keeps only points within the reduced region.
        if(ipfig.gt.0) then
          tiny=0.
          phibot=-tiny
          if(icrysym.eq.1) phitop=45.*pi/180. +tiny
          if(icrysym.eq.2) phitop=30.*pi/180. +tiny
          if(icrysym.eq.3) phitop=60.*pi/180. +tiny
          if(icrysym.eq.4) phitop=45.*pi/180. +tiny
          if(icrysym.eq.5) phitop=90.*pi/180. +tiny
          if(icrysym.eq.6) phitop=    pi      +tiny
          if(icrysym.eq.7) phitop= 2.*pi      +tiny
          npx=0

          do ip=1,np
            if(xp(ip).ge.phibot. and . xp(ip).le.phitop) then
              npx=npx+1
              xp(npx)=xp(ip)
              yp(npx)=yp(ip)
              wgtp(npx)=wgtp(ip)
            endif
          enddo
          np=npx
        endif

c *** eliminates crosses contained in 2nd and 3rd stereographic triangle.
        if(icrysym.eq.1 .and. ipfig.gt.0) then
          npx=0
          do ip=1,np
            thx=acos(yp(ip))
            pro=(-cos(xp(ip))*sin(thx)+cos(thx))/sqrt(2.)
            if(pro.ge.0) then
              npx=npx+1
              xp(npx)=xp(ip)
              yp(npx)=yp(ip)
              wgtp(npx)=wgtp(ip)
            endif
          enddo
          np=npx
        endif

c *** assigns poles to bins according to their weight
        wgtmax=0.
        do ip=1,np
          if(wgtp(ip).gt.wgtmax) wgtmax=wgtp(ip)
        enddo
        wgtmax=1.0001*wgtmax
        binsize=wgtmax/10.
        do ibin=1,10
          npbin(ibin)=0
        enddo
        do ip=1,np
          call project(xp(ip),yp(ip),1.d0,iproj)
          ibin=(wgtp(ip)/binsize)+1
          npbin(ibin)=npbin(ibin)+1
          intwgt(ip)=ibin
        enddo

c *** orders the poles sequentially by weight
        jp=1
        do ibin=1,10
          do ip=1,np
            if(intwgt(ip).eq.ibin) then
              xpx(jp) =xp(ip)
              ypx(jp) =yp(ip)
              jp=jp+1
            endif
          enddo
        enddo
      
        write(uw1,'('' weight  npoles'')')
        npacum=0

c     for gunplot based plotting by Arul - START
        nfile=outfileid//'_CC.DAT'
        if (XDGNU) then     
         write(99, '(''plot "'',a12,''" using 1:2 notitle with lines lt
     $1 lc -1 ,'', a1)')  nfile, backsl
	     plines = plines + 1
        endif
c     for gunplot based plotting by Arul - END

        do ibin=1,10
          write(uw1,'(i4,i6,''  wgt & npoles'')') ibin,npbin(ibin)
          if(npbin(ibin).gt.0) then

            write(uw1,'(8f10.4)')
     #           (xpx(ip)*radx+xori,ip=npacum+1,npacum+npbin(ibin))
            write(uw1,'(8f10.4)')
     #           (ypx(ip)*radx+yori,ip=npacum+1,npacum+npbin(ibin))

            nfile=outfileid//'_X'//char(48+ibin-1)//'.DAT'
            iunit=20+ibin            
            
c     for gunplot based plotting by Arul - START
            if ( ibin .lt. 10 ) then
               if (XDGNU) then
               write(99, '(''"'',a12,''" using 1:2 notitle with points 
     $ lt 1 lc -1, '', a1)')  nfile, backsl   
                  plines = plines + 1
               endif
            else           
               if (XDGNU) then
               write(99, '(''"'',a12,''" using 1:2 notitle with points
     $ lt 1 lc -1'')')  nfile 
                  plines = plines + 1	
                  XDGNU = .FALSE.
               endif
            endif     
c     for gunplot based plotting by Arul - END
          
          open(unit=iunit,file=nfile,status='unknown')
          write(iunit,'(2f10.4)') (xpx(ip)*radx+xori,ypx(ip)*radx+yori
     #                              ,ip=npacum+1,npacum+npbin(ibin))
            write(iunit,'(2a10)') dash,dash
          endif
          npacum=npacum+npbin(ibin)
        enddo

c *********************************************************************
c     END OF BLOCK FOR PROCESSING POINT POLE FIGURES (irepr=1)

      endif      ! end of if(irepr.eq.1)
c *********************************************************************

c *********************************************************************
c     BLOCK FOR PROCESSING INTENSITY LINE POLE FIGURES (irepr=0)

      if(irepr.eq.0) then
c *********************************************************************

c *** accumulates poles in the elements of the grid.
c *** if spread>0 each pole is split into a 'cluster' of nps poles,
c *** preserving the total weight.

      do i=1,np2
      do j=1,mp2
        f(i,j)=0.
      enddo
      enddo
      do ip=1,np
        xps(1)=xp(ip)
        yps(1)=yp(ip)

        if(spread.gt.0.) call spread_poles(2,spreadr,nps,xp(ip),yp(ip))

        do ips=1,nps
          x1=xps(ips)
          y1=yps(ips)
          if(y1.lt.0.0) then
            x1=x1+pi
            y1=-y1
          endif
          z1=acos(y1)
          w1=wgtp(ip)*frac(ips)

          if(x1.lt.(-pi-hdeltx)) x1=x1+2.*pi
          if(x1.gt.( pi-hdeltx)) x1=x1-2.*pi
          jphi=int((x1+pi+hdeltx)/deltx+2.)
          if(igrid.eq.1) ithe=int((cos1-y1)/delty+2.)
          if(igrid.eq.0) ithe=int((z1-z(1))/deltz+2.)
          if(ithe.eq.0) ithe=1             ! fix potential polar cup effect
          f(ithe,jphi)=f(ithe,jphi)+w1
        enddo
      enddo

c *** calculates pole density from accumulated volume fraction in each element.
c *** pole density is normalized such as to be 1 for a random texture.
c *** imposes boundary conditions on the outer elements of the grid.

      mp1=mgrid+1
      np1=ngrid+1
      avf=npol*twgt/(2.*pi)

c *** assigns same density to first ring to smooth polar cup.
      fpole=0.0
      do j=2,mp1
        fpole=fpole+f(1,j)
      enddo
      fnorm=avf*(1.-cos(z(1)))*2.*pi
      fpole=fpole/fnorm
      do j=2,mp1
        f(1,j)=fpole
      enddo

c *** Calculates intensities and normalizes (1 is random texture).
c *** 'abs_intensity' : option added Nov 1 2017 for scaling intensities based  
c *** on actual volume fraction'totwgt'associated with the texture.
c *** This was added to deal with the quartz twinned fractions. Default is one.

      abs_intensity=1.
	  total_pf_wgt=0
	  do ipfxx=1,ndiftexts
	    total_pf_wgt=  total_pf_wgt + pf_wgt_factor(ipfxx)
	  enddo
      abs_intensity=pf_wgt_factor(ndiftex)
 
      do i=2,np1
        fnorm=avf*(cos(z(i-1))-cos(z(i)))*deltx
        do j=2,mp1
          f(i,j)=f(i,j)/fnorm  * abs_intensity
        enddo
      enddo

c *** this block calculates volume fractions at grid elements for later
c     performing pole figure differences
      if(ndiftex.le.6 .and. ndifpol.le.6) then
        do i=1,np1
        do j=2,mp1
          fvfr(i,j,ndifpol,ndiftex)=f(i,j)*(cos(z(i-1))-cos(z(i)))*
     #                                    deltx
        enddo
        enddo
      endif

c *** calculate axisymmetric profile of pole figure fthe(i)     (OPTIONAL)
c     'fthe(i)' is intensity and 'fphi(i)' is volume fraction.
c *** Since f(i,j) is defined to be 1 for random texture, its integral over
c     Euler space gives 2*pi. As a consequence volume fractions follow from
c     integrating f(i,j) and dividing by 2*pi.

      if(ndiftex.eq.1 .and. ndifpol.eq.1) then
        nfile=outfileid//'_profile.dat'
        open(unit=18,file=nfile,status='unknown')
      endif

      write(18,'(a)') textfile(ndiftex)
      write(18,'(''poles   '',4i3)') (miller(i,ndifpol),i=1,nind)
      write(18,
     #      '(''      ang       int     vdens     vfrac     vfacc'')')

      do i=1,np1
        fthe(i)=0.
        do j=2,mp1
          fthe(i)=fthe(i)+f(i,j)
        enddo
        fthe(i)=fthe(i)/mgrid    ! average intensity
      enddo
      fthe(np2)=fthe(np1)   ! equatorial boundary condition

      do i=1,np2
        fphi(i)=(cos(z(i-1))-cos(z(i)))*fthe(i)   ! volume fraction in ring
      enddo

      vfacc=fphi(1)
      do i=1,np1
        thetax=acos(y(i))
        write(18,'(f10.2,4f10.5)') thetax*180./pi,fthe(i),
     #                             fthe(i)*sin(thetax),fphi(i),vfacc
        vfacc=vfacc+fphi(i+1)
      enddo

c *** this block enforces axisymmetry in pole figure.
      if(isym.eq.-1) then
        do i=1,np1
        do j=2,mp1
          f(i,j)=fthe(i)
        enddo
        enddo
      endif      ! end of isym=-1 condition

c *** impose boundary condition on equator elements (REQUIRED).
      mh  =mgrid/2
      mhp1=mh+1
      mhp2=mh+2
      do j=2,mhp1
        f(np2,j)=f(np1,j+mh)
      enddo
      do j=mhp2,mp1
        f(np2,j)=f(np1,j-mh)
      enddo

c *** impose boundary condition for 2*pi periodicity (REQUIRED).
      do i=1,np2
        f(i,1)=f(i,mp1)
        f(i,mp2)=f(i,2)
      enddo

c ************************************************************************
c *** smooth PF by mixing the cell intensity with the intensity of the two
c     nearest neighbor cells using empirical coefficents: a0+2*a1+2*a2=1
c *** the amount of 'mix' is maximum at the pole and decays rapidly
c     towards the equator, with empirical factor 1< smthfr <0

      if(ismth.ne.0) then
        do ifilter=1,ismth      ! runs filter multiple times
          do i=2,np2
            thex=acos(y(i))*180./pi
            smthfr=2./(1.+exp(90.*(thex/90.)**4))
            do j=1,mp2
              fphi(j)=f(i,j)
            enddo
            fphi(0)=fphi(mp2-2)
            fphi(mp2+1)=fphi(3)
            a0= 0.30 + (1.-smthfr)* 0.70
            a1= 0.25 - (1.-smthfr)* 0.25
            a2= 0.10 - (1.-smthfr)* 0.10
            do j=2,mp1
              f(i,j)=a0*fphi(j)+a1*(fphi(j-1)+fphi(j+1))
     #                         +a2*(fphi(j-2)+fphi(j+2))
            enddo
            f(i,1)=f(i,mp1)
            f(i,mp2)=f(i,2)
          enddo
        enddo      ! end of multiple-filter loop
      endif

c *** smooth PF by mixing the cell intensity with the intensity of an
c *** axisymmetric 'belt'. The smoothing factor decays rapidly.
c
c     if(ismth.eq.1) then
c       do i=2,np2
c         thex=acos(y(i))*180./pi
c         smthfr=2./(1.+exp(90.*(thex/90.)**4))
c         fthe(i)=0
c         do j=2,mp1
c           fthe(i)=fthe(i)+f(i,j)
c         enddo
c         fthe(i)=fthe(i)/mgrid
c         do j=2,mp1
c           f(i,j)=(1-smthfr)*f(i,j)+smthfr*fthe(i)
c         enddo
c         f(i,1)=f(i,mp1)
c         f(i,mp2)=f(i,2)
c       enddo
c     endif
c **************************************************************************

c *** writes table with grid coordinates (phi,th) and intensities (OPTIONAL)
c     write(19,*)
c     write(19,*) '   ang   phiave      ph1    ph2    ph3    ...'
c     write(19,'(18x,36f7.1)') (x(j)*180./pi,j=2,mgrid+1,2)
c     do i=1,np2
c       write(19,'(f6.2,3x,f6.2,3x,36f7.2)')
c    #            acos(y(i))*180./pi,fthe(i),(f(i,j),j=2,mgrid+1,2)
c     enddo

c *** writes table with: 'phi  cos(theta)  x  y  intensity' (OPTIONAL)
c     do i=1,np2
c       do j=1,mp2
c         ycart=y(i)
c         xcart=x(j)
c         call project(xcart,ycart,rad,iproj)
c         write(19,'(4f10.4,f10.2)') x(j),y(i),xcart,ycart,f(i,j)
c       enddo
c     enddo


c *** writes table with: 'phi  theta  pole_vol_fraction' (OPTIONAL)
      if(ndiftex.eq.1 .and. ndifpol.eq.1) then
        nfile=outfileid//'_grid_vfr.dat'
        open(unit=17,file=nfile,status='unknown')
      endif
      write(17,*) '   grid volume fractions for poles'
      write(17,*)
      write(17,'('' theta\phi'',37f10.2)') (x(j)*180./pi,j=2,mp1)

      do i=1,np1
        thetax=acos(y(i))*180./pi
        write(17,'(f10.2,37f10.5)') 
     #             thetax,(fvfr(i,j,ndifpol,ndiftex),j=2,mp1)
      enddo

c *** writes (phi,theta,zero,vfr) to create a discrete texture file
c *** using only basal pole information and eliminating low fractions
      cutoff=0.1
      zero=0.0
      do i=1,np1
        thetax=acos(y(i))*180./pi
        do j=2,mp1
          if(fvfr(i,j,ndifpol,ndiftex).gt.cutoff)
     #          write(17,'(3f10.2,3x,f10.5)') 
     #          x(j)*180./pi,thetax,zero,fvfr(i,j,ndifpol,ndiftex)
        enddo
      enddo


c ********************************************************
c *** defines range of cells for plotting intensity lines.
c *** full interval runs from -180<phi<180 and 0<theta<90

      if(ipfig.eq.0) then
          ntop=np2
        if(isym.le.0 .or. ifull.eq.0) then
          mtop=mgrid+2
          mbot=1
        else if(isym.eq.1 .or. isym.eq.2) then
          mtop=3*mgrid/4+2
          mbot=mgrid/4+1
        else if(isym.eq.3) then
          mtop=mgrid+2
          mbot=mgrid/2+1
        else if(isym.eq.4) then
          mtop=3*mgrid/4+2
          mbot=mgrid/2+1
        endif
      endif

      if(ipfig.gt.0) then
          ntop=np2
        if(icrysym.eq.1) then
          mtop=5*mgrid/8+2
          mbot=4*mgrid/8+1
          ntop=13            ! quick fix to get maximum inside 1st triangle
        else if (icrysym.eq.2) then
          mtop=7*mgrid/12+2
          mbot=6*mgrid/12+1
        else if (icrysym.eq.3) then
          mtop=8*mgrid/12+2
          mbot=6*mgrid/12+1
        else if (icrysym.eq.4) then
          mtop=5*mgrid/8+2
          mbot=4*mgrid/8+1
        else if (icrysym.eq.5) then
          mtop=3*mgrid/4+2
          mbot=2*mgrid/4+1
        else if (icrysym.eq.6) then
          mtop=4*mgrid/4+2
          mbot=2*mgrid/4+1
        else if (icrysym.eq.7) then
          mtop=  mgrid+2
          mbot=  1
        endif
      endif

c ***************************************************************************
c     END OF BLOCK FOR PROCESSING INTENSITY LINES

      endif      ! end of if(irepr.eq.0)

  280 continue
c ***************************************************************************
c *** generates the segments defining the iso-level lines and, optionally,
c     crosses at the points where the intensity is below the first level.
c *** writes coordinates of crosses in FILEID_XX.dat.
c *** writes coordinates of maximum in FILEID_MX.dat.
c *** writes coordinates of level lines in FILEID_nn.dat (1 file per level).
c *** writes coordinates of crosses, maximum and level lines (all) in POLE8.OUT

      if(irepr.eq.0) then

c *** writes table with grid coordinates (phi,th) and intensities for
c *** plotting with POD2K (for Bjorn's consumption)
        if(ndiftex.eq.1 .and. ndifpol.eq.1) then
          nfile=outfileid//'_grid_int.DAT'
          open(unit=19,file=nfile,status='unknown')
        endif
        if(ipfig.ge.-1) write(19,'(a)') textfile(ndiftex)
        if(ipfig.eq.-2) write(19,'(a)') polefile(ndifpol)
        if(nind.eq.3) write(19,'(''poles   '',3i3)')
     #     (miller(i,ndifpol),i=1,nind)
        if(nind.eq.4) write(19,'(''poles   '',3i3)')
     #      miller(1,ndifpol),miller(2,ndifpol),miller(4,ndifpol)
        write(19,*) '      phi     theta      int'
        do i=1,ngrid+2          ! alternative limits: mbot,mtop
          do j=1,mgrid+2        ! alternative limits: 1,ntop
            phidx=x(j)*180./pi
            if(phidx.gt.185.) phidx=phidx-360.     ! necessary for ipfig=-2
            write(19,'(3f10.3)') phidx,acos(y(i))*180./pi,f(i,j)
          enddo
        enddo

        call isolev (ntop,mbot,mtop,default,xori,yori,rad,radx,
     $       icrysym,xlgnu)
	 
c        nfile=outfileid//'_XX.DAT'
c        if (icros.eq.0 .and. xlgnu) then
c		 write(99,*) '"', nfile, '" ','using 1:2 notitle with dots lt 0'
c		 plines = plines + 1
c		endif
       endif

  290 continue      ! end of ndiftex loop      
  300 continue      ! end of ndifpol loop

c *****************************************************************************
c *** calculates Pole Figure Difference parameter for consecutive texture pairs
c     sum1=sum2=2*pi / PFD=0 --> no difference / PFD=1 --> maximum difference

      do ndiftex=1,ndiftexts

        if(ndiftex.eq.2) then
          nfile=outfileid//'_PF_diff.DAT'
          open(unit=20,file=nfile,status='unknown')
        endif
      
      if(ndiftex/2*2-ndiftex .eq. 0) then
        write(20,'(a50)') inputfile(ndiftex-1)
        write(20,'(a50)') inputfile(ndiftex)
        write(20,*)
        do ndifpol=1,ndifpoles
          sum1= 0.
          sum2= 0.
          pfdif=0.
          do i=1,np1
          do j=2,mp2
            sum1=sum1+abs(fvfr(i,j,ndifpol,ndiftex-1))
            sum2=sum2+abs(fvfr(i,j,ndifpol,ndiftex))
            pfdif=pfdif+abs(fvfr(i,j,ndifpol,ndiftex)-
     #                      fvfr(i,j,ndifpol,ndiftex-1))
          enddo
          enddo
          pfdif=pfdif/(sum1+sum2)
          write(20,'(''poles   '',4i3)') (miller(i,ndifpol),i=1,nind)
c         write(20,'(''sum1'',f9.5,5x,''sum2'',f9.5)') sum1,sum2   ! sum1=sum2=6.28
          write(20,'(''PF difference parameter'',f9.5)') pfdif
          write(20,*)
        enddo
      endif

      enddo

c ***************************************************************************
c *** writes settings in a 'profile' file POLE8.PRO to use for repeat runs

      close(unit=uw1)
      open(ur3,file='pole8.pro',status='unknown')

c *** general parameters associated with dot and line representation
      write(ur3,*)        ' ifull iproj irepr  isym ncmax'
      write(ur3,'(10i6)')   ifull,iproj,irepr,isym,ncmax
      write(ur3,*)        ' iper1 iper2 iper3'
      write(ur3,'(10i6)')   iper(1),iper(2),iper(3)
c *** parameters associated with grid (line representation)
      write(ur3,*)             ' igrid mgrid ngrid'
      write(ur3,'(3i6)')         igrid,mgrid,ngrid
c *** parameters associated with PF massaging (line representation)
      write(ur3,*)             ' ishft ismth  pfrot'
      write(ur3,'(2i6,f8.2)')    ishft,ismth, pfrot*180./pi
c *** intensity line related parameters set inside ISOLEV
      write(ur3,*)           ' icros isepa  spread'
      write(ur3,'(2i6,f8.2)')  icros,isepa, spread
      write(ur3,*)        ' nlevels'
      write(ur3,'(i6)')     nlevels
      write(ur3,*)        ' rlevel(l)'
      write(ur3,'(8f9.2)') (rlevel(l),l=1,nlevels)

      close(unit=ur3)
      
c *** for gnuplot based plotting by Arul - START

      nfile=outfileid//'_XX.DAT'
      if (icros.eq.0 .and. irepr.eq.0) then
         write(99,*) '"', nfile,'"','using 1:2 notitle with dots lt 0'
         plines = plines + 1
      endif
      close(unit=99) 
	  
      nfile = outfileid//'.p'
      open(unit=98, file=nfile , status='unknown')
      do i=1,plines-1
         read(98, '(a)') tmp1
         write(9, *) trim(tmp1)
      enddo
      write(9, *)' set term postscript eps color blacktext'
      write(9, *)' set output "',outfileid, '.eps"'
      write(9, *)'replot;'
      close(unit=9)
      close(unit=98, status='delete')

c *** for gunplot based plotting by Arul - END
      
      stop
      end
c
c ***************************************************************************
c     subroutine circles   --->   version 22/mar/08
c
c *** If IOPTION=1 generates the points of the circular sections that define
c *** the pole figure or the inverse pole figure assuming unit radious. It
c *** also defines coordinates of labels to be attached to the PF or IPF.

c *** If IOPTION=2, for each PF or IPF shifts coordinates by (xori,yori),
c *** scales by RAD, and writes them into 'FILEID_CC.DAT' & 'FILEID_LB.DAT'.
c ***************************************************************************

      subroutine circles (xori,yori,rad,radx,icrysym,ioption)
	  
	  IMPLICIT NONE	
	  
      include 'pole8.dim'
		
	  double precision xori, yori, rad, radx
	  double precision xl, yl, dang, ang0, ang, angmax, delta, ichar
	  double precision t1, t2, xc, yc, xaux, yaux, zaux
	  
	  INTEGER icrysym, ioption, nlabels, i, j, n, np, npoints 
	   
      dimension xc(1000),yc(1000)
      dimension   xl(10),yl(10)
      character*4 label(10)     
      save      np,nlabels,label,xl,yl,xc,yc

c ********************************************************************
      if(ioption.eq.1) then

      dang =pi/180.
      nlabels=3

c *** for a direct pole figure defines quarter, half or full circle
c *** depending on the symmetrization

      if(ipfig.le.0) then

        xl(1)=1.05
        yl(1)=0.01
        xl(2)=0.00
        yl(2)=1.05
        xl(3)=0.5
        yl(3)=1.1

        if(isym.le.0 .or. ifull.eq.0) then
          npoints=360
          ang0=0.
        else if(isym.eq.1 .or. isym.eq.2) then
          npoints=180
          ang0=-pi/2.
        else if(isym.eq.3) then
          npoints=180
          ang0=0.
        else if(isym.eq.4) then
          npoints= 90
          ang0=0.
        endif
        xc(1)=0.0
        yc(1)=1.04
        xc(2)=0.0
        yc(2)=0.0
        xc(3)=1.04
        yc(3)=0.0
        xc(4)=0.0
        yc(4)=0.0
        np=5
        do n=0,npoints
          ang= n*dang + ang0
          xc(np)=cos(ang)
          yc(np)=sin(ang)
          np=np+1
        enddo
        xc(np)=0.0
        yc(np)=0.0
      endif

c ***********************************************************************
c *** for an inverse pole figure defines circular section and axes' labels
c *** depending on the crystal symmetry

      if(ipfig.gt.0) then

        if(icrysym.eq.1) npoints= 45
        if(icrysym.eq.2) npoints= 30
        if(icrysym.eq.3) npoints= 60
        if(icrysym.eq.4) npoints= 45
        if(icrysym.eq.5) npoints= 90
        if(icrysym.eq.6) npoints=180
        if(icrysym.eq.7) npoints=360
        ang=npoints/180.*pi
        angmax= 90./180.*pi
        if(ang.gt.angmax) ang=angmax

        xl(1)=1.05
        yl(1)=0.01
        xl(2)=1.05*cos(ang)
        yl(2)=1.05*sin(ang)
        xl(3)=0.5
        yl(3)=yl(2)+0.2

        if(icrysym.eq.1) then
          label(1)=' 110'
          label(2)=' 111'
          xl(2)=0.9
          yl(2)=0.9
        elseif(icrysym.eq.2) then
          label(1)='2110'
          label(2)='1010'
        elseif(icrysym.eq.3) then
          label(1)='2110'
          label(2)='1120'
        elseif(icrysym.eq.4) then
          label(1)=' 100'
          label(2)=' 110'
        elseif(icrysym.eq.5) then
          label(1)=' 100'
          label(2)=' 010'
        endif

      endif

c ***************************************************
      if(ipfig.gt.0 .and . icrysym.ne.1) then
        xc(1)=0.0
        yc(1)=0.0
        np=2
        do n=0,npoints
          ang= n*dang
          xc(np)=cos(ang)
          yc(np)=sin(ang)
          np=np+1
        enddo
        xc(np)=0.0
        yc(np)=0.0
      endif

c ***************************************************
      if(ipfig.gt.0 .and. icrysym.eq.1) then

c *** defines projection of [101] circle (1st stereogr triangle) for
c *** IPF of cubic materials

        npoints=45
        xc(1)=0.0
        yc(1)=0.0
        np=2
        delta=1./sqrt(3.)/npoints
        do n=0,npoints
          yaux=n*delta
          xaux=sqrt((1.-yaux**2)/2.)
          zaux=xaux
          t1=sqrt(1.-zaux)/sqrt(xaux**2+yaux**2)
          if(iproj.eq.0) then
            xc(np)=xaux*t1
            yc(np)=yaux*t1
          else if (iproj.eq.1) then
            t2=t1/sqrt(1.+zaux)
            xc(np)=xaux*t2
            yc(np)=yaux*t2
          endif
          np=np+1
        enddo
        xc(np)=0.0
        yc(np)=0.0

c *** defines projection of [011] circle (2nd stereographic triangle) for
c *** IPF of cubic materials
c
c       np=np+1
c       delta=(1.-1./sqrt(3.))/npoints
c       do n=0,npoints
c         xaux=n*delta + 1./sqrt(3.) - 1.e-6
c         yaux=sqrt((1.-xaux**2)/2.)
c         zaux=yaux
c         t1=sqrt(1.-zaux)/sqrt(xaux**2+yaux**2)
c         if(iproj.eq.0) then
c           xc(np)=xaux*t1
c           yc(np)=yaux*t1
c         else if (iproj.eq.1) then
c           t2=t1/sqrt(1.+zaux)
c           xc(np)=xaux*t2
c           yc(np)=yaux*t2
c         endif
c         np=np+1
c       enddo
c       xc(np)=0.0
c       yc(np)=0.0
c
c *** defines projection of [001] circle (3rd stereographic triangle) for
c *** IPF of cubic materials
c
c       np=np+1
c       dang=pi/180.
c       do n=0,npoints
c         ang= n*dang
c         xc(np)=cos(ang)
c         yc(np)=sin(ang)
c         np=np+1
c       enddo
c       xc(np)=0.0
c       yc(np)=0.0

      endif
c ********************************************************************
      endif      ! end of ioption=1


c ********************************************************************
      if(ioption.eq.2) then
        write(uw1,'(i5,''   points in the circular section'')') np
        write(uw1,'(8f10.4)') (xc(i)*radx+xori,i=1,np)
        write(uw1,'(8f10.4)') (yc(i)*radx+yori,i=1,np)
        write(11,'(2f10.4)')   (xc(i)*radx+xori,yc(i)*radx+yori,i=1,np)
c        write(11,*)   
        write(11,'(2a10)')     dash,dash

        do i=1,nlabels
          ichar=(i-(i/3)*3)
          if(ichar.ne.0 .and. ipfig.le.0) write(14,'(2f10.4,4x,i2)')
     #                         xl(i)*rad+xori,yl(i)*rad+yori,iper(i)
          if(ichar.ne.0 .and. ipfig.gt.0) write(14,'(2f10.4,4x,a4)')
     #                         xl(i)*rad+xori,yl(i)*rad+yori,label(i)
          if(ichar.eq.0) write(14,'(2f10.4,4x,4i1)')
     #        xl(i)*rad+xori,yl(i)*rad+yori,(abs(isnlbl(j)),j=1,nind)
        enddo

        open(94, file='polec.p', status='unknown')
        write(94,*) xc(1)*radx+xori,yc(1)*radx+yori
        write(94,*) xc(2)*radx+xori,yc(2)*radx+yori
        write(94,*) xc(np-1)*radx+xori,yc(np-1)*radx+yori
        close(94)

      endif
c ********************************************************************

      return
      end
C
C ***********************************************************************
C    SUBROUTINE CONCATENATE      VERSION 08/dec/03
C
C    BASED ON SUBROUTINE 'LINPLUS5' WHICH WAS AN IMPROVED VERSION OF
C    SUBROUTINE 'LINFULL' BY R. LEBENSOHN.
C
C    CONSTRUCTS INTENSITY LINES OUT OF THE SEGMENTS GENERATED BY POLE8.FOR
C
C    *  GIVEN AN INTENSITY LINE DEFINED BY A CHAIN OF CONCATENATED SEGMENTS,
C       BOTH EXTREMES OF THE CHAIN ARE LEFT OPEN AND SEGMENTS
C       ARE ATTACHED TO 'TOP' OR 'BOTTOM' END UNTIL THERE IS NO MATCH.
C    *  CREATES ONE OUTPUT FILE 'fileid_nn.DAT' FOR EACH INTENSITY LEVEL.
C       THIS FILE CONTAINS ALL LINES OF A GIVEN INTENSITY 'nn', SEPARATED
C       BY BLANK LINES. THIS FACILITATES PLOTTING WITH 'ORIGIN' OR 'GNUPLOT'.
C    *  POLE8 HANDLES FULL, HALF AND QUARTER CIRCLE POLE FIGURES.
C       CREATES A FILE 'fileid_CC.DAT' WITH THE POINTS OF THE FULL,
C       HALF OR QUARTER CIRCLE TO BE DRAWN.
C    *  POLE8 CREATES A FILE 'fileid_XX.DAT' WITH THE COORDINATES OF THE
C       POINTS WHERE THE INTENSITY IS BELOW THE LOWEST LEVEL LINE.
C    *  POLE8 CREATES A FILE 'fileid_MX.DAT' WITH THE COORDINATES OF THE
C       POINT WHERE THE INTENSITY IS MAXIMUM.
C
C    OUTPUT:
C           fileid_CC.DAT  --> CARTESIAN POINTS OF CIRCLE
C           fileid_XX.DAT  --> COORDINATES OF CROSSES FOR INTENSITY < minline
C           fileid_MX.DAT  --> COORDINATES OF MAXIMUM INTENSITY POINT
C           fileid_nn.DAT  --> ONE FILE FOR EACH INTENSITY LINE
C ************************************************************************

      SUBROUTINE CONCATENATE (xori,yori,rad,nseg,levbot,levtop,xlgnu)
	  
	  IMPLICIT NONE
	  
      include 'pole8.dim'
	  
      logical xlgnu
	  
      integer NLEVMOST, levbot, levtop, nseg, plines, plmax
	  integer i, j, coef, kbot, ktop, lt, leveli, levelid
	  integer ndig1, ndig2, ndig3, npoints, nsegshort, nunit
	  
	  double precision xori, yori, rad
	  double precision err, rlevelmax, seglength, segmax
	  double precision xl, yl, xbot, ybot, xtop, ytop
	  
	  character*1 backsl
      parameter(backsl='\\')
      CHARACTER NFILE*12
	  
      common /gnuplot/ plines, plmax
	  
      DIMENSION XL(-NSMAX:NSMAX),YL(-NSMAX:NSMAX)	  
      
	  
      SAVE                NLEVMOST      
      DATA                NLEVMOST /0/

      PI=PI
      ERR =0.00005
	  
      IF ( NLEVELS .GT. NLEVMOST ) THEN
         NLEVMOST = NLEVELS
         xlgnu = .TRUE.
      ELSE
         xlgnu = .FALSE.
      ENDIF
    
c     for gunplot based plotting by Arul - START  
      IF ( xlgnu ) THEN
         nfile=outfileid//'_CC.DAT'
         write(99,*) 'plot "', nfile, '" ','using 1:2 notitle ',
     $' with lines lt 1 lc -1, \'
         plines = plines + 1
c       '\'
       ENDIF
c     for gunplot based plotting by Arul - END
       
       SEGMAX=0.D0
       NSEGSHORT=0
       DO I=1,NSEG
          SEGLENGTH= SQRT( (XI(I)-XF(I))**2+(YI(I)-YF(I))**2 )
          IF(SEGLENGTH.LT.ERR/2.) THEN
             NSEGSHORT=NSEGSHORT+1
             IF(SEGLENGTH.GT.SEGMAX) SEGMAX=SEGLENGTH
             SEGLEVEL(I)=999
          ENDIF
       ENDDO

C     IF(NSEGSHORT.NE.0) THEN
C       WRITE(*,'(I5,''  SEGMENTS SHORTER THAN'',F10.6)') NSEGSHORT,
C    #            ERR/2.
C       WRITE(*,'('' THE LONGEST IS '',F10.6)') SEGMAX
C       WRITE(*,'('' ALL WILL BE ELIMINATED '')')
C     ENDIF

C *** FINDS MAXIMUM INTENSITY LEVEL AND SHIFTS THE COMMA TO DEFINE
C *** 'LEVELID' USING THE FIRST THREE SIGNIFICANT DIGITS.
C *** ALGORITHM VALID FOR   10**(-5) < RLEVMAX < 10**(+4)

      RLEVELMAX=0.D0
      DO I=LEVBOT,LEVTOP
        IF(RLEVEL(I).GT.RLEVELMAX) RLEVELMAX=RLEVEL(I)
      ENDDO

      RLEVELMAX=99.  ! hard wired for plotting multiple poles not exceeding 99.

      DO I=-4,4
        IF(RLEVELMAX .LT. 10**I) THEN
          COEF= 10**(3-I)
          GO TO 10
        ENDIF
      ENDDO
   10 CONTINUE

C *** OPENS A FILE FOR EACH LEVEL. THE RENORMALIZED INTENSITY OF THE LEVEL
C *** (FIRST THREE NON-ZERO DIGITS) APPEARS IN THE NAME OF THE FILE.

C      WRITE(*,'(''   ORDER   LEVEL LEVELID  RLEVEL(I)'')')
      DO I=LEVBOT,LEVTOP
        LEVELID=(RLEVEL(I)*COEF)
C        WRITE(*,'(3I8,F10.3)') I,LEVEL(I),LEVELID,RLEVEL(I)

        NDIG1=(LEVELID/100)*100
        NDIG2= LEVELID-NDIG1
        NDIG2=(NDIG2/10)*10
        NDIG3= LEVELID-NDIG1-NDIG2
        NDIG1= NDIG1/100
        NDIG2= NDIG2/10
        NDIG3= NDIG3/1
        	
        lt = i;
        if (lt.eq.6) lt = 18
        NFILE= OUTFILEID
     #         //CHAR(48+NDIG1)//CHAR(48+NDIG2)//CHAR(48+NDIG3)//'.DAT'
        NUNIT= 20+LEVEL(I)
        OPEN(NUNIT,FILE=NFILE,STATUS='unknown')
		
c        IF ( xlgnu ) THEN

c     for gunplot based plotting by Arul - START
        IF ( plmax.lt.I) THEN
           plmax  = I
           IF ( ICROS .EQ. 0 ) THEN
              write(99, '(''"'',a12,''" using 1:2 title " '',f5.1,
     $''" with lines lt 1 lc '',i2,'','',a1)') nfile,rlevel(i),lt,backsl
              plines = plines + 1
           ELSE                    
              IF ( I .LT. NLEVELS ) THEN
                 write(99, '(''"'',a12,''" using 1:2 title " '',f5.1,
     $''" with lines lt 1 lc '',i2,'','',a1)') nfile,rlevel(i),lt,backsl
                 plines = plines + 1
              ELSE
                 write(99, '(''"'',a12,''" using 1:2 title " '',f5.1,
     $''" with lines lt 1 lc '',i2)') nfile,rlevel(i), lt
                 plines = plines + 1	 
              ENDIF
           ENDIF
        ENDIF
c     for gunplot based plotting by Arul - END


C       WRITE(*,'(I4,2X,A)') NUNIT,NFILE
C       WRITE(NUNIT,'(2A10)') '     X    ',
C    #        'LVL'//CHAR(48+NDIG1)//CHAR(48+NDIG2)//CHAR(48+NDIG3)
      ENDDO

C *** CONSTRUCTS EACH LINE BY PICKING A SEGMENT AND CHECKING THE OTHERS
C *** UNTIL IT FINDS THOSE THAT FIT EACH EXTREME. REDEFINES THE EXTREMES
C *** AND REPEATS THE PROCESS UNTIL THERE IS NO MATCH.
C *** THE LEVEL OF THE SEGMENTS THAT ARE USED IS REDEFINED SEGLEVEL(I)=999
C *** IN ORDER TO SKIP THEM IN THE NEXT ITERATIONS.

      DO 20 I=1,NSEG

C     PICKS THE FIRST UNUTILIZED SEGMENT AND STARTS A NEW CHAIN

      IF(SEGLEVEL(I).NE.999) THEN
        KBOT=0
        KTOP=1
        LEVELI=SEGLEVEL(I)
        XBOT=XI(I)
        YBOT=YI(I)
        XTOP=XF(I)
        YTOP=YF(I)
        XL(KBOT)=XBOT
        YL(KBOT)=YBOT
        XL(KTOP)=XTOP
        YL(KTOP)=YTOP
        SEGLEVEL(I)=999
      ELSE
        GO TO 20
      ENDIF

C     ATTACHES THE SEGMENTS AT BOTH ENDS OF THE CHAIN.
C     SKIPS A SEGMENT IF IT HAS BEEN USED ALREADY OR IF IT REPRESENTS
C     A DIFFERENT LEVEL.

100   DO 40 J=1,NSEG
      IF(SEGLEVEL(J).NE.LEVELI) GO TO 40
      IF(ABS(XI(J)-XTOP).LT.ERR .AND. ABS(YI(J)-YTOP).LT.ERR) THEN
        KTOP=KTOP+1
        XTOP=XF(J)
        YTOP=YF(J)
        XL(KTOP)=XTOP
        YL(KTOP)=YTOP
        SEGLEVEL(J)=999
        GO TO 100
      ELSEIF(ABS(XF(J)-XTOP).LT.ERR .AND. ABS(YF(J)-YTOP).LT.ERR) THEN
        KTOP=KTOP+1
        XTOP=XI(J)
        YTOP=YI(J)
        XL(KTOP)=XTOP
        YL(KTOP)=YTOP
        SEGLEVEL(J)=999
        GO TO 100
      ELSEIF(ABS(XI(J)-XBOT).LT.ERR .AND. ABS(YI(J)-YBOT).LT.ERR) THEN
        KBOT=KBOT-1
        XBOT=XF(J)
        YBOT=YF(J)
        XL(KBOT)=XBOT
        YL(KBOT)=YBOT
        SEGLEVEL(J)=999
        GO TO 100
      ELSEIF(ABS(XF(J)-XBOT).LT.ERR .AND. ABS(YF(J)-YBOT).LT.ERR) THEN
        KBOT=KBOT-1
        XBOT=XI(J)
        YBOT=YI(J)
        XL(KBOT)=XBOT
        YL(KBOT)=YBOT
        SEGLEVEL(J)=999
        GO TO 100
      ENDIF

   40 CONTINUE

C *** ADDS THE CHAIN OF ORDERED SEGMENTS TO THE FILE ASSOCIATED WITH
C *** LEVELI AND PUTS DASHES AT THE END TO SEPARATE THEM FROM THE ONES
C *** BELONGING TO A DIFFERENT ISOCLINE OF THE SAME VALUE.

      NUNIT=20+LEVELI
      WRITE(NUNIT,'(2F10.5)')
     #             (xl(j)*rad+xori,yl(j)*rad+yori,j=kbot,ktop)
c      WRITE(NUNIT,*) 
      WRITE(NUNIT,'(2A10)') DASH,DASH

C *** WRITES THE CHAIN OF ORDERED SEGMENTS INTO 'POLE8.OUT'.

      NPOINTS=KTOP+1+ABS(KBOT)
      WRITE(uw1,'(2I10)') LEVELI,NPOINTS
      WRITE(uw1,'(8F10.4)') (xl(j)*rad+xori,j=kbot,ktop)
      WRITE(uw1,'(8F10.4)') (yl(j)*rad+yori,j=kbot,ktop)

   20 CONTINUE

      WRITE(uw1,'(''    999    999'')')     ! used to terminate data reading

      RETURN
      END
c
c ***********************************************************************
c     subroutine crystal_symmetry   --->   version 09/JAN/2009
c
c *** If IOPTION=1:
c     Reads crystal symmetry 'icrysym' and unit cell parameters.
c     Generates vectors 'cvec(i,n)' of the unit cell.
c     Generates symmetry operators 'h(i,j,nsymop)' for all crystal symmetries.
c *** If IOPTION=2:
c     Reads Miller indices of systems in 3 or 4-index notation 'isn(i)'
c     & 'isb(i)'. Calculates normal & burgers vectors 'sn(i)' & 'sb(i)'
c *** If IOPTION=3:
c     Generates 'nequiv' crystallographically equivalent orientations sneq(i,n)
c     of normal vector sn(i) by applying all the symmetry operations to it.
c     Discards repeated orientations and defines 'nequiv'.
c *** Simmetry parameter ICRYSYM:
c        1: CUBIC
c        2: HEXAGONAL
c        3: TRIGONAL
c        4: TETRAGONAL
c        5: ORTHORHOMBIC
c        6: MONOCLINIC
c        7: TRICLINIC
c ***********************************************************************

      subroutine crystal_symmetry (ioption,ur1,icrysym,
     #                             isn,sn,sneq,isb,sb,nequiv)
	  
	  IMPLICIT NONE 
	  double precision sn, sb, sneq, pi, snnor, sndif
	  double precision cdim, cang, cvec, h, hx, ang
	  
	  integer ur1, ioption, icrysym, isn, isb, nequiv, isign
	  integer i, j, k, m, mn, n, nr, nrot, nsymop, itag
	  
      dimension h(3,3,24),hx(3,3,6),itag(24)
      dimension isn(4),sn(3),sneq(3,24),isb(4),sb(3)
      dimension cdim(3),cang(3),cvec(3,3)

      character crysym*5
      save h,nsymop,cvec
      data pi /3.1415926535898/

c ****************************************************************************

      if(ioption.eq.1) then

        read(ur1,*)
        read(ur1,'(a)') crysym
        icrysym=0
        if(crysym.eq.'cubic' .or. crysym.eq.'CUBIC') icrysym=1
        if(crysym.eq.'hexag' .or. crysym.eq.'HEXAG') icrysym=2
        if(crysym.eq.'trigo' .or. crysym.eq.'TRIGO') icrysym=3
        if(crysym.eq.'tetra' .or. crysym.eq.'TETRA') icrysym=4
        if(crysym.eq.'ortho' .or. crysym.eq.'ORTHO') icrysym=5
        if(crysym.eq.'monoc' .or. crysym.eq.'MONOC') icrysym=6
        if(crysym.eq.'tricl' .or. crysym.eq.'TRICL') icrysym=7
        if(icrysym.eq.0) then
          write(*,*) ' *** CANNOT RECOGNIZE THE CRYSTAL SYMMETRY'
          stop
        endif

        READ(UR1,*) (CDIM(i),i=1,3),(CANG(i),i=1,3)
        DO I=1,3
          CANG(I)=CANG(I)*PI/180.
        ENDDO

c *** assumes 'c' coincident with 'z' and 'a' in the plane 'xz'

        CVEC(1,1)=SIN(CANG(2))
        CVEC(2,1)=0.
        CVEC(3,1)=COS(CANG(2))
        CVEC(1,2)=(COS(CANG(3))-COS(CANG(1))*COS(CANG(2)))/SIN(CANG(2))
        CVEC(3,2)=COS(CANG(1))
        CVEC(2,2)=SQRT(1.-CVEC(1,2)**2-CVEC(3,2)**2)
        CVEC(1,3)=0.
        CVEC(2,3)=0.
        CVEC(3,3)=1.

        DO J=1,3
        DO I=1,3
          CVEC(I,J)=CDIM(J)*CVEC(I,J)
        ENDDO
        ENDDO

        DO I=1,3
        DO J=1,3
          DO M=1,6
            HX(I,J,M)=0.d0
          ENDDO
          DO N=1,24
            H(I,J,N)=0.d0
          ENDDO
        ENDDO
        ENDDO

c *** identity operation ---> triclinic & all symmetries
      do i=1,3
        h(i,i,1)=1.d0
      enddo
      nsymop=1

c *** 180 deg rotation around (001) ---> orthorhombic, monoclinic
      if(icrysym.eq.5 .or. icrysym.eq.6) then
        h(1,1,2)= cos(pi)
        h(2,2,2)= cos(pi)
        h(3,3,2)= 1.d0
        h(1,2,2)=-sin(pi)
        h(2,1,2)= sin(pi)
        nsymop=2
      endif

c *** x-mirror & y-mirror ---> orthorhombic
      if(icrysym.eq.5) then
        h(1,1,3)=-1.d0
        h(2,2,3)= 1.d0
        h(3,3,3)= 1.d0

        h(1,1,4)= 1.d0
        h(2,2,4)=-1.d0
        h(3,3,4)= 1.d0
        nsymop=4
      endif

c *** cubic symmetry
      if(icrysym.eq.1) then

c *** rotations of (pi/3) & (2*pi/3) around <111>
        hx(1,3,1)= 1.d0
        hx(2,1,1)= 1.d0
        hx(3,2,1)= 1.d0

        hx(1,2,2)= 1.d0
        hx(2,3,2)= 1.d0
        hx(3,1,2)= 1.d0

        do m=1,2
          do n=1,nsymop
            mn=m*nsymop+n
            do i=1,3
            do j=1,3
            do k=1,3
              h(i,j,mn)=h(i,j,mn)+hx(i,k,m)*h(k,j,n)
            enddo
            enddo
            enddo
          enddo
        enddo
        nsymop=mn

c *** mirror across the plane (110)
        hx(1,2,3)= 1.d0
        hx(2,1,3)= 1.d0
        hx(3,3,3)= 1.d0

        do n=1,nsymop
          mn=nsymop+n
            do i=1,3
            do j=1,3
            do k=1,3
              h(i,j,mn)=h(i,j,mn)+hx(i,k,3)*h(k,j,n)
            enddo
            enddo
            enddo
        enddo
        nsymop=mn

c *** rotations of 90, 180, 270 around x3

        do m=1,3
          ang=pi/2.*float(m)
          hx(1,1,m)= cos(ang)
          hx(2,2,m)= cos(ang)
          hx(3,3,m)= 1.0
          hx(1,2,m)=-sin(ang)
          hx(2,1,m)= sin(ang)
          hx(1,3,m)= 0.0
          hx(3,1,m)= 0.0
          hx(2,3,m)= 0.0
          hx(3,2,m)= 0.0
        enddo

        do m=1,3
          do n=1,nsymop
            mn=m*nsymop+n
              do i=1,3
              do j=1,3
              do k=1,3
                h(i,j,mn)=h(i,j,mn)+hx(i,k,m)*h(k,j,n)
              enddo
              enddo
              enddo
          enddo
        enddo
        nsymop=mn

      endif                    !end of condition for icrysym=1

c *** hexagonal, trigonal and tetragonal symmetry

      if(icrysym.ge.2 .and. icrysym.le.4) then
        if(icrysym.eq.2) nrot=6
        if(icrysym.eq.3) nrot=3
        if(icrysym.eq.4) nrot=4

c *** mirror plane at ang=30 deg or 60 deg or 45 deg with respect to x1
ccc        ang=pi/float(nrot)

        if(icrysym.eq.2) ang=pi/6.       
        if(icrysym.eq.3) ang=pi/6.      ! CT changed 10/17/2017
        if(icrysym.eq.4) ang=pi/4.

        h(1,1,2)= cos(ang)**2-sin(ang)**2
        h(2,2,2)=-h(1,1,2)
        h(3,3,2)= 1.d0
        h(1,2,2)= 2.*cos(ang)*sin(ang)
        h(2,1,2)= h(1,2,2)
        nsymop=2

c --> CT added on oct/17/2017 for dealing with lesser-symmetry quartz
c        if(icrysym.eq.3) then
c          h(:,:,2)=0.
c          nsymop=1
c        endif

c *** rotations of 2*pi/6 around axis <001> for hexagonals.
c *** rotations of 2*pi/3 around axis <001> for trigonals.
c *** rotations of 2*pi/4 around axis <001> for tetragonals.
        do nr=1,nrot-1
          ang=nr*2.*pi/nrot
          hx(1,1,nr)= cos(ang)
          hx(2,2,nr)= cos(ang)
          hx(3,3,nr)= 1.d0
          hx(1,2,nr)=-sin(ang)
          hx(2,1,nr)= sin(ang)
        enddo

        do m=1,nrot-1
          do n=1,nsymop
            mn=m*nsymop+n
            do i=1,3
            do j=1,3
            do k=1,3
              h(i,j,mn)=h(i,j,mn)+hx(i,k,m)*h(k,j,n)
            enddo
            enddo
            enddo
          enddo
        enddo
        nsymop=mn

      endif               !end of condition for icrysym= 2,3,4

      write(10,*)
      write(10,'(''  # of symmetry operations='',i4)') nsymop
      write(10,'(''  symmetry matrices'')')
      write(10,'(i3,9f7.3)') (n,((h(i,j,n),j=1,3),i=1,3),n=1,nsymop)

      endif               !end of condition for ioption=1

c **************************************************************************
c   Converts Miller-Bravais indices of plane normal and slip direction
c   into normalized vectors sn(i) and sb(i), respectively.
c   Indices for cubic (1), tetragonal (4), orthorhombic (5), monoclinic (6)
c   & triclinic (7) systems are in 3-index notation.
c   For hexagonal (2) & trigonal (3) systems uses 4-index notation.
c **************************************************************************

      if (ioption.eq.2) then

        if(icrysym.eq.2 .or. icrysym.eq.3) then
          isn(3)=isn(4)
          isb(1)=isb(1)-isb(3)
          isb(2)=isb(2)-isb(3)
          isb(3)=isb(4)
        endif

c *** assumes 'a' coincident with 'x' and 'b' in the plane 'xy'
c       sn(1)= isn(1)/cvec(1,1)
c       sn(2)=(isn(2)-cvec(1,2)*sn(1))/cvec(2,2)
c       sn(3)=(isn(3)-cvec(1,3)*sn(1)-cvec(2,3)*sn(2))/cvec(3,3)
c *** assumes 'c' coincident with 'z' and 'a' in the plane 'xz'
        sn(3)= isn(3)/cvec(3,3)
        sn(1)=(isn(1)-cvec(3,1)*sn(3))/cvec(1,1)
        sn(2)=(isn(2)-cvec(1,2)*sn(1)-cvec(3,2)*sn(3))/cvec(2,2)

        snnor=sqrt(sn(1)**2+sn(2)**2+sn(3)**2)
        do j=1,3
          sn(j)=sn(j)/snnor
          if(abs(sn(j)).lt.1.e-03) sn(j)=0.
        enddo

c *** this block specific for EPSC & VPSC

c       do i=1,3
c         sb(i)=isb(1)*cvec(i,1)+isb(2)*cvec(i,2)+isb(3)*cvec(i,3)
c       enddo
c       sbnor=sqrt(sb(1)**2+sb(2)**2+sb(3)**2)
c       do j=1,3
c         sb(j)=sb(j)/sbnor
c         if(abs(sb(j)).lt.1.e-03) sb(j)=0.
c       enddo
c
c       prod=sn(1)*sb(1)+sn(2)*sb(2)+sn(3)*sb(3)
c       IF(PROD.GE.1.E-3) THEN
c         WRITE(*,'('' SYSTEM IS NOT ORTHOGONAL !!'')')
c         WRITE(*,'('' ISN='',3I7)') (ISN(J),J=1,3)
c         WRITE(*,'('' ISB='',3I7)') (ISB(J),J=1,3)
c         WRITE(*,'(''   N='',3F7.3)') (SN(J),J=1,3)
c         WRITE(*,'(''   B='',3F7.3)') (SB(J),J=1,3)
c         STOP
c       ENDIF

      endif      ! end of if(ioption.eq.2)

c **************************************************************************
c *** generates all symmetry related vectors sneq(i,n) with z>0.
c *** eliminates redundant poles: coincidents and opposites
c **************************************************************************

      if(ioption.eq.3) then

        do n=1,nsymop
          itag(n)=0
          do i=1,3
          sneq(i,n)=0.d0
            do j=1,3
              sneq(i,n)=sneq(i,n)+h(i,j,n)*sn(j)
            enddo
          enddo
        enddo

        if(icrysym.ne.7) then      ! nsymop=1 for trigonal
          do m=1,nsymop-1
            if(itag(m).eq.0) then
              do n=m+1,nsymop
                sndif=abs(sneq(1,m)-sneq(1,n))+abs(sneq(2,m)-sneq(2,n))
     #               +abs(sneq(3,m)-sneq(3,n))
                if(sndif .le. 0.0001) itag(n)=1
                sndif=abs(sneq(1,m)+sneq(1,n))+abs(sneq(2,m)+sneq(2,n))
     #               +abs(sneq(3,m)+sneq(3,n))
                if(sndif .le. 0.0001) itag(n)=1
              enddo
            endif
          enddo
        endif

        nequiv=0
        do n=1,nsymop
          if(itag(n).eq.0) then
            nequiv=nequiv+1
            isign=1
            if(sneq(3,n).lt.0.) isign=-1
            sneq(1,nequiv)=isign*sneq(1,n)
            sneq(2,nequiv)=isign*sneq(2,n)
            sneq(3,nequiv)=isign*sneq(3,n)
          endif
        enddo

      endif            !end of if(ioption=3)
c **************************************************************************

      return
      end
c
c *************************************************************************
      subroutine euler(iopt,ph,th,om,a)

      implicit none
c      real com, cph, cth, pi, som, sth, sph
      double precision a, ph, th, om
	  double precision com, cph, cth, pi, som, sph, sth
      integer iopt
c      implicit real*8 (a-h,o-z)
      dimension a(3,3)
      data pi /3.1415926535898/

c     CALCULATE THE EULER ANGLES ASSOCIATED WITH THE TRANSFORMATION
c     MATRIX A(I,J) IF IOPT=1 AND VICEVERSA IF IOPT=2
c     A(i,j) TRANSFORMS FROM SYSTEM sa TO SYSTEM ca.
c     ph,th,om ARE THE EULER ANGLES OF ca REFERRED TO sa.
c
      if(iopt.eq.1) then
        th=acos(a(3,3))
        if(abs(a(3,3)).ge.0.9999) then
          om=0.d0
          ph=atan2(a(1,2),a(1,1))
        else
          sth=sin(th)
          om =atan2(a(1,3)/sth,a(2,3)/sth)
          ph =atan2(a(3,1)/sth,-a(3,2)/sth)
        endif
        th=th*180.d0/pi
        ph=ph*180.d0/pi
        om=om*180.d0/pi
      else if(iopt.eq.2) then
        sph=sin(ph*pi/180.)
        cph=cos(ph*pi/180.)
        sth=sin(th*pi/180.)
        cth=cos(th*pi/180.)
        som=sin(om*pi/180.)
        com=cos(om*pi/180.)
        a(1,1)= com*cph-sph*som*cth
        a(2,1)=-som*cph-sph*com*cth
        a(3,1)= sph*sth
        a(1,2)= com*sph+cph*som*cth
        a(2,2)=-sph*som+cph*com*cth
        a(3,2)=-sth*cph
        a(1,3)= sth*som
        a(2,3)= com*sth
        a(3,3)= cth
      endif

      return
      end
c
c ************************************************************************
c
c     subroutine isolev      --->      version 07/feb/08
c
c *** calculates contour lines (f=integer*step) of a positive function
c *** f(i,j) defined at the coordinate points x(j) , y(i) of a
c *** rectangular grid with 1<i<ngrid and mbot<j<mtop.
c *** the points along the rim of the rectangular grid serve as boundary
c *** condition, and level lines extend half-way between these points and
c *** the ones of the closest inner ring.
c ************************************************************************

      subroutine isolev (ntop,mbot,mtop,default,xori,yori,rad,radx,
     #                   icrysym, xlgnu)

      IMPLICIT NONE
	  include 'pole8.dim'
	  
	  integer mtop, ntop, mbot, nbot, icrysym, i, j, k, l, isoc 
	  integer ifmax, jfmax, id, jd, kc, il, jl, iskip, is, js 
	  integer levbot, levtop, ls, n, nil, nilx, nsegms, nsegmx
	  
	  double precision xori, yori, rad, radx, th12, th13, themax, thx
	  double precision tiny, toler, v12, v13, xx, yy, x1, y1
	  double precision x12, y12, x13, y13, x2, y2, x3, y3, xmax, ymax
	  double precision ff, f1, f2, f3, fbot,fk, fmax, fmin, ftop
	  double precision phimax, pro, pro12, pro13, finter
	  
      logical   xlgnu
      dimension xx(3),yy(3),ff(3),is(2),js(2),v12(3),v13(3)
      integer   default	
      integer   plines, plmax	
	  
      common /gnuplot/ plines, plmax
	  
      dimension id(9),jd(9),kc(9)
      data id/-1,-1,0,1,1,1,0,-1,-1/,jd/0,-1,-1,-1,0,1,1,1,0/
      data kc/1,2,3,2,3,1,3,1,2/

c *** write grid values for debugging purposes
c     write(uw1,'(10x,24f7.3)') (y(i),i=1,ntop)
c     do j=mbot,mtop
c       write(uw1,'(f7.3,3x,24f7.3)') x(j),(f(i,j),i=1,ntop)
c     enddo

c *** looks for maximum & minimum value of f assuming that the rim
c *** elements of the grid are used as boundary conditions for interpolating.
c *** only at the north pole accounts explicitly for the boundary.
c *** prompts to enter the incremental step for the intensity lines.

      fmax=f(1,2)
      fmin=f(1,2)

      do i=1,ntop-1
      do j=mbot+1,mtop-1
        if(fmax.le.f(i,j)) then      ! .LE. required when fmax=f(1,2)
          fmax=f(i,j)
          xmax=x(j)
          ymax=y(i)
          ifmax=i
          jfmax=j
        endif
        if(fmin.ge.f(i,j)) then      ! .GE. required when fmin=f(1,2)
          fmin=f(i,j)
        endif
      enddo
      enddo

      if(ifmax.eq.1) write(*,'('' MAXIMUM COINCIDES WITH NORTH POLE'')')
c
c *** the following procedure detects whether the maximum falls on the
c *** lines that define the grid instead of on the center of an element.

      if(ifmax.ne.1) then
        toler=1.d-3*abs(fmax)
        if (abs(f(ifmax-1,jfmax)-f(ifmax,jfmax)).le.toler) then
          ymax=0.5d0*(y(ifmax-1)+y(ifmax))
        elseif(abs(f(ifmax+1,jfmax)-f(ifmax,jfmax)).le.toler) then
          ymax=0.5d0*(y(ifmax+1)+y(ifmax))
        endif
        if (abs(f(ifmax,jfmax-1)-f(ifmax,jfmax)).le.toler) then
          xmax=0.5d0*(x(jfmax-1)+x(jfmax))
        elseif(abs(f(ifmax,jfmax+1)-f(ifmax,jfmax)).le.toler) then
          xmax=0.5d0*(x(jfmax+1)+x(jfmax))
        endif
      endif

      phimax=xmax*180./pi
      themax=acos(ymax)*180./pi
      write(*,*)
      write(*,'('' fmax='',f7.2,''   at phi='',f7.2,''  theta='',f7.2)')
     #             fmax,phimax,themax

c *** gives the option of using linear or exponential scale, and
c     defines the values of the levels

      if(default.ge.0) then
        if(default.eq.1) then
          print *
          print *, 'enter 0 for power of 2 spaced lines '
          print *, 'enter 1 for equally spaced lines ---> '
          read(*,*) isepa
          print *
          print *, 'enter contour lines STEP as a positive number'
          if(isepa.eq.0) print *, ' level(l)= 2**(STEP*(l-2))  ---> '
          if(isepa.eq.1) print *, ' level(l)= l*STEP           ---> '
          read(*,*) step
        endif
        
        nlevels=nlmax
        do l=1,nlevels
          level (l)= l
          if(isepa.eq.0) rlevel(l)= 2.**(step*(l-2))
          if(isepa.eq.1) rlevel(l)= l*step
        enddo
      endif

      if(default.eq.1) then
        write(*,*)
        write(*,*) ' the following levels (up to fmax) will be plot'
        write(*,'(8f7.2)') (rlevel(l),l=1,nlevels)

        write(*,*)
        write(*,*) 'enter 0 to plot crosses below lower line'
        write(*,*) 'enter 1 for not plotting crosses            ---> '
        read(*,*) icros
      endif

c *** increases slightly the values of f that coincide with contour
c     lines in order to avoid interpolation complications

      tiny=1.e-04
      do i=1,ntop
        do j=mbot,mtop
          do l=1,nlevels
            toler=f(i,j)-rlevel(l)
            if(toler.gt.0. .and. toler.lt.tiny) f(i,j)=f(i,j)+tiny
            if(toler.lt.0. .and.-toler.lt.tiny) f(i,j)=f(i,j)-tiny
          enddo
        enddo
      enddo

      levbot= 0
      levtop= 0
      do l=1,nlevels
        if(rlevel(l).le.fmax) levtop=levtop+1
        if(rlevel(l).ge.fmin .and. levbot.eq.0) levbot=l
      enddo
      
c      write(*,*) 'fmax and fmin', fmax, fmin
c      write(*,*) nlmax, nlevels, levtop, levbot
      
      if(levtop.eq.nlmax) then
        write(*,*)
        write(*,'(''**** NUMBER OF LEVELS   nlevels='',i3,
     #            ''  MAY NOT BE SUFFICIENT'')') nlevels
        write(*,'('' --> INCREASE PARAMETER nlmax IN POLE8.DIM OR ''
     #                   ,''INCREASE LEVEL SEPARATION step     '')')
c        pause
      endif

**************************************************************************

c *** calculates the coordinates of the level lines associated with f(i,j).
c *** will plot crosses for f(i,j) < firstlevel

      nil=0
      nsegms=0
      do 110 i=2,ntop-1
      do 110 j=mbot+1,mtop-1
        ff(1)=f(i,j)
        xx(1)=x(j)
        yy(1)=y(i)

      if(ff(1).lt.rlevel(levbot)) then
        nil=nil+1
        xnil(nil)=xx(1)
        ynil(nil)=yy(1)
      endif

c *** averages the coordinates and the function for the intermediate ***
c *** point between the center of element (i,j) and each one of the  ***
c *** 4 diagonal neighbouring elements                               ***
      do 105 l=2,8,2
      il=i+id(l)
      jl=j+jd(l)
      is(1)=i+id(l-1)
      js(1)=j+jd(l-1)
      is(2)=i+id(l+1)
      js(2)=j+jd(l+1)
      ff(2)=(f(i,j)+f(il,jl)+f(is(1),js(1))+f(is(2),js(2)))/4.
      xx(2)=(x(j)+x(jl)+x(js(1))+x(js(2)))/4.
      yy(2)=(y(i)+y(il)+y(is(1))+y(is(2)))/4.
      if(i.gt.2) go to 27
      if(l.ne.2.and.l.ne.8) go to 27
      ff(2)=f(1,j)
      yy(2)=y(1)
   27 continue

c      if(ff(2).lt.rlevel(levbot)) then
c        nil=nil+1
c        xnil(nil)=xx(2)
c        ynil(nil)=yy(2)
c      endif
c
c *** averages the coordinates and the function for the vertices of ****
c *** the triangles that lie at each side of the diagonal           ****
      do 100 ls=1,2
      ff(3)=(f(i,j)+f(is(ls),js(ls)))/2.
      xx(3)=(x(j)+x(js(ls)))/2.
      yy(3)=(y(i)+y(is(ls)))/2.
      if(i.gt.2) go to 37
      if(l.ne.2.and.l.ne.8) go to 37
      if(js(ls).ne.j) go to 37
      ff(3)=f(1,j)
      yy(3)=y(1)
   37 continue

c      if(ff(3).lt.rlevel(levbot)) then
c        nil=nil+1
c        xnil(nil)=xx(3)
c        ynil(nil)=yy(3)
c      endif

c *** evaluates contour lines between each pair of sides defining the **
c *** triangle. Pairs are taken cyclically using the array kc(k).     **
      do k=1,3
        f1 =ff(kc(k))
        x1 =xx(kc(k))
        y1 =yy(kc(k))
        f2 =ff(kc(k+3))
        x2 =xx(kc(k+3))
        y2 =yy(kc(k+3))
        f3 =ff(kc(k+6))
        x3 =xx(kc(k+6))
        y3 =yy(kc(k+6))
        iskip=1
        if(f1.lt.f2 .and. f1.lt.f3) then
          ftop=min(f2,f3)
          fbot=f1
          iskip=0
        else if(f1.gt.f2 .and. f1.gt.f3) then
          ftop=f1
          fbot=max(f2,f3)
          iskip=0
        endif
        if(iskip.eq.0) then
          isoc=1
          do while(isoc.le.nlevels .and. rlevel(isoc).le.ftop)
            if(rlevel(isoc).ge.fbot) then
              fk=rlevel(isoc)
              call linint(x1,y1,f1,x2,y2,f2,x12,y12,fk)
              call linint(x1,y1,f1,x3,y3,f3,x13,y13,fk)
              nsegms=nsegms+1
              xi(nsegms)=x12
              yi(nsegms)=y12
              xf(nsegms)=x13
              yf(nsegms)=y13
              seglevel(nsegms)=level(isoc)
            endif
            isoc=isoc+1
          enddo
          if(nsegms.gt.nsmax) then
            write(*,*) '*** DIMENSION nsmax EXCEEDED'
            write(*,*) '*** INCREASE  nsmax TO  ',nsegms,' IN POLE8.DIM'
            stop
          endif
        endif
      enddo      ! end of do k=1,3
  100 continue
  105 continue
  110 continue

c **************************************************************************
c *** For cubic inverse pole figures keeps only the segments and crosses
c *** within the first stereographic triangle.
c *** Segments that cross the stereographic circle are interpolated.
c *** Scales the first stereogr. triangle to a unit radious for cubic ipf's.

      if(icrysym.eq.1 .and. ipfig.gt.0) then
        if(nil.ne.0 .and. icros.eq.0) then
          nilx=0
          do i=1,nil
            thx=acos(ynil(i))
            pro=(-cos(xnil(i))*sin(thx)+cos(thx))/sqrt(2.)
            if(pro.ge.0) then
              nilx=nilx+1
              xnil(nilx)=xnil(i)
              ynil(nilx)=ynil(i)
            endif
          enddo
          nil=nilx
        endif

        nsegmx=0
        do i=1,nsegms
          x12=xi(i)
          y12=yi(i)
          x13=xf(i)
          y13=yf(i)

          th12=acos(y12)
          th13=acos(y13)
          v12(1)=cos(x12)*sin(th12)
          v12(2)=sin(x12)*sin(th12)
          v12(3)=         cos(th12)
          pro12 =sqrt(0.5)*(-v12(1)+v12(3))
          v13(1)=cos(x13)*sin(th13)
          v13(2)=sin(x13)*sin(th13)
          v13(3)=         cos(th13)
          pro13 =sqrt(0.5)*(-v13(1)+v13(3))

          if(pro12.ge.0 .or. pro13.ge.0) then
            if(pro12.ge.0 .and. pro13.le.0) then
              finter=abs(pro12)/(abs(pro12)+abs(pro13))
              do n=1,3
                v13(n)=v12(n)+(v13(n)-v12(n))*finter
              enddo
              x13=atan2(v13(2),v13(1))
              y13=v13(3)
            endif
            if(pro12.le.0 .and. pro13.ge.0) then
              finter=abs(pro13)/(abs(pro12)+abs(pro13))
              do n=1,3
                v12(n)=v13(n)+(v12(n)-v13(n))*finter
              enddo
              x12=atan2(v12(2),v12(1))
              y12=v12(3)
            endif
            nsegmx=nsegmx+1
            xi(nsegmx)=x12
            yi(nsegmx)=y12
            xf(nsegmx)=x13
            yf(nsegmx)=y13
            seglevel(nsegmx)=seglevel(i)
          endif
        enddo
        nsegms=nsegmx
      endif

c **************************************************************************
c *** projects coordinates of segments & crosses (phi,cos(theta)) as (x,y)

      call project(xmax,ymax,1.d0,iproj)
      do i=1,nsegms
        call project(xi(i),yi(i),1.d0,iproj)
        call project(xf(i),yf(i),1.d0,iproj)
      enddo
      if(nil.ne.0 .and. icros.eq.0) then
        do i=1,nil
          call project(xnil(i),ynil(i),1.d0,iproj)
        enddo
      endif

c *** writes coordinates (x,y) of crosses in POLE8.OUT and NFILE_XX.DAT
      write(uw1,'(2i5,''   crosses'')') icros,nil
      if(nil.ne.0 .and. icros.eq.0) then
        write(uw1,'(8f10.4)') (xnil(i)*radx+xori,i=1,nil)
        write(uw1,'(8f10.4)') (ynil(i)*radx+yori,i=1,nil)

        write(12,'(2f10.4)') (xnil(i)*radx+xori,ynil(i)*radx+yori,
     #                       i=1,nil)
c        write(12,*)
        write(12,'(2a10)')    dash,dash
      endif

c *** writes maximum in POLE8.OUT
      write(uw1,'('' max='',f6.2)') fmax      !read as character inside PLOTPF8
      write(uw1,*) '  xmax   ymax'
      write(uw1,'(2f7.3)') xmax*radx+xori,ymax*radx+yori !rd as real in PLOTPF8

c *** writes maximum and its position in NFILE_MX.DAT
      write(13,'(3f7.3)') xmax*radx+xori,ymax*radx+yori,fmax

c *** writes values of levels kept in POLE8.OUT
      write(uw1,'(i3,''  levels'')') levtop-levbot+1
      do l=levbot,levtop
        write(uw1,'(i3,f8.2)') level(l),rlevel(l)
      enddo

c *** concatenates the segments that belong to each of the level lines.
c *** writes the coordinates of the lines in 'POLE8.OUT'
c *** writes FILEID_nn.DAT with the coordinates of each intensity level.
      
      call concatenate (xori,yori,radx,nsegms,levbot,levtop,xlgnu)	 

      return
      end
c
c **************************************************************************
      subroutine linint(x1,y1,f1,x2,y2,f2,x,y,f)

c *** interpolates linearly between f1 & f2 for a given value f

	  IMPLICIT NONE
	  
	  double precision x1, y1, x2, y2, x, y, f1, f2, f
      x=(x2-x1)*(f-f1)/(f2-f1)+x1
      y=(y2-y1)*(f-f1)/(f2-f1)+y1
      return
      end

c ***************************************************************************
      subroutine project (x,y,rad,iproj)

c *** gives cartesian coordinates of the projection of a point defined
c *** by the polar coordinates x=phi,y=cos(theta).
c *** iproj=0 stands for equal area and iproj=1 for stereographic proj.
	  IMPLICIT NONE
	  
      double precision x, y, rad, t1, t2, cx, sx
	  integer iproj
	  
      t1=    sqrt(abs(1.-y))
      t2= t1/sqrt(abs(1.+y))
      cx= cos(x)
      sx= sin(x)
      if (iproj.eq.0) then
        x  = cx*t1*rad
        y  = sx*t1*rad
      else if (iproj.eq.1) then
        x  = cx*t2*rad
        y  = sx*t2*rad
      endif

      return
      end
c
c *********************************************************************
c     subroutine read_popla_epf   --->   version 12/feb/08
c
c     reads intensities f(i,j) from a *.epf file generated by popLA.
c     assigns intensities f(i,j) to corresponding grid points x(j),y(i).
c     defines boundary conditions on f(i,j) for proper interpolation.
c *********************************************************************.

      subroutine read_popla_epf (ninputfiles,ndifpoles,
     #                           mp2,np2,ntop,mbot,mtop)
	
	  IMPLICIT NONE	
	  
      include 'pole8.dim'	  
	
	  integer ninputfiles, ndifpoles, ntop, mp1, mp2, np1, np2
	  integer i, j, ix, mbot, mtop, n10, n01, multi
	  
	  double precision deltang, topang, fpole
	  
	  character prosa*80

      prosa=prosa      ! to fool the compiler

c *** reads a table of pole intensities defined every 5 degrees
c     in phi (0-355) and theta (0-90). Presets mgrid=72 & ngrid=18.
c *** defines extra 'outer' values for boundary conditions.
c *** creates a 'texture' file for each pole in the *.epf file

      deltang =pi/180.*5.       ! default
      mp1=mgrid+1
      np1=ngrid+1
      mp2=mgrid+2
      np2=ngrid+2
      ntop=np2                  ! default
      mtop=mp2
      mbot=1

      ndifpoles=0
      do ix= 1,ninputfiles
        open(ur2,file=inputfile(ix),status='old')
        do multi=1,maxp
          if(multi.ne.1) read(ur2,'(a)',end=77) prosa
          ndifpoles=ndifpoles+1
          read(ur2,'(a)') prosa
          read(ur2,'(1x,3i1,1x,2f5.1)') (miller(i,ndifpoles),i=1,nind),
     #                                   deltang,topang
          ntop=(topang+0.001)/deltang+2
          deltang=deltang*pi/180.
          n10=ndifpoles/10
          n01=ndifpoles-n10*10
          polefile(ndifpoles)=
     #       'pole_'//char(48+n10)//char(48+n01)//'.dat'
          open(uw2,file=polefile(ndifpoles),status='unknown')

          read(ur2,'(1x,18f4.0)') ((f(i,j),j=2,mp1),i=1,np1)

c *** temporary block for dealing with Jayant Jain format
c         ntop=ngrid+2
c         deltang=5.*pi/180.
c         do i=1,np1
c         do j=2,mp1
c           read(ur2,*) dum1,dum2,f(i,j)
c           f(i,j)=f(i,j)*100.
c         enddo
c         enddo

c *** averages all measurements at the pole
          fpole=0.
          do j=2,mp1
            fpole=fpole+f(1,j)
          enddo
          fpole=fpole/mgrid
          do j=2,mp1
            f(1,j)=fpole
          enddo

c *** *.EPF files list intensities for PHI=0,5,10,...355 deg and for
c *** THE=0,5,...TOPANG. Need to define centers of the grid cells accordingly.
          y(1)=0.9999
          do i=2,ntop
            y(i)=cos((i-1)*deltang)
            f(ntop,j)=f(ntop-1,j)
          enddo
c *** following applies when TOPANG=90 deg. For TOPANG<90 it is innocuous.
          y(np1)=cos(pi/180.*89.)
          y(np2)=cos(pi/180.*91.)

          do j=1,mp2
            x(j)=(j-2)*deltang
            f(np2,j)=f(np1,j)
          enddo

          do i=1,ntop
            f(i,1)  =f(i,mp1)
            f(i,mp2)=f(i,2)
            do j=1,mp2
              f(i,j)=f(i,j)/100.
            enddo
          enddo

          write(uw2,'(3i2,''   poles'')') (miller(i,ndifpoles),i=1,nind)
          do i=1,ntop
            write(uw2,'(12f7.2)') (f(i,j),j=1,mp2)
          enddo

          close(uw2)
        enddo      ! end of multi
   77   continue
        enddo      ! end of ix

      return
      end

c **************************************************************************
c     subroutine read_texture_files   -->   version 12/feb/08
c
c *** opens one or several input files 'ninputfiles', each containing one
c *** or several discrete textures.
c *** splits those into 'ndiftexts' single texture files 'TEXT_nn.DAT'
c **************************************************************************

      subroutine read_texture_files (ninputfiles,ndiftexts,ntfpf,ngrtf)
     
      IMPLICIT NONE
  
      include 'pole8.dim'
	  
      INTEGER j, ix, n10, n01, ngrain, multi, ninputfiles
      INTEGER ndiftexts, ntfpf, ngrtf
  
      double precision ang1,ang2,ang3,wgtx
	  
      dimension  ntfpf(maxt),ngrtf(maxt,maxt)
      character  prosa*80, nomen*1

      prosa=prosa      ! to fool the compiler
      pi   =pi

      ndiftexts=0
      do ix=1,ninputfiles
        ntfpf(ix)=0
        open(ur2,file=inputfile(ix),status='old')
        write(uw8,'(a)') inputfile(ix)
        do multi=1,maxt     ! eventually sets lower limit to total textures
          read(ur2,'(a)',end=77) prosa
          read(ur2,'(a)') prosa
          read(ur2,'(a)') prosa
          read(ur2,*)     nomen,ngrain
          write(uw8,'(a,i10)') nomen,ngrain
          ntfpf(ix)=ntfpf(ix)+1
          ngrtf(ix,ntfpf(ix))=ngrain
          if(ngrain.gt.ngmax) then
            write(*,*)
            write(*,'('' WARNING !! THERE ARE'',I8,'' ORIENTATIONS IN'',
     #                '' TEXTURE FILE'')') NGRAIN
            write(*,'('' THE MAXIMUM DIMENSION IS NGMAX='',I8)') NGMAX
            write(*,'('' ---> INCREASE PARAMETER NGMAX IN POLE8.DIM'')')
            stop
          endif
          ndiftexts=ndiftexts+1

          n10=ndiftexts/10
          n01=ndiftexts-n10*10
          textfile(ndiftexts)=
     #         'text_'//char(48+n10)//char(48+n01)//'.dat'
          open(uw2,file=textfile(ndiftexts),status='unknown')
            write(uw2,'(a1,i10)') nomen,ngrain
            do j=1,ngrain
              read(ur2,*)  ang1,ang2,ang3,wgtx
              write(uw2,*) ang1,ang2,ang3,wgtx      ! degrees
c              write(uw2,*) ang1*180./pi,ang2*180./pi,ang3*180./pi,wgtx   ! radians
            enddo
          close(uw2)
        enddo
   77   continue
      enddo

      return
      end
c
c ***************************************************************************

      subroutine spread_poles (ioption,spred,nps,x1,y1)

	  IMPLICIT NONE 
	  
	  include 'pole8.dim'
	  
	  double precision tfrac, v1, v2, v3, h, st, sp
	  double precision spred, x1, y1, alf, dalf, bet, cp, ct, seca	  
	  integer ioption, nps, m, mpart, n, npart    
	
      dimension h(3,3)

c **************************************************************************
c *** generates a set of nps unitary vectors spread around (0,0,1) and
c *** gives a weight frac(i) to each one.
c *** Both the vectors vs(i) and their relative weights (frac) depend on the
c *** model proposed for doing the spread and can be modified by the user.

      IF(IOPTION.EQ.1) THEN
      npart=4
      dalf=spred/npart
      nps=1
      vs(1,1)=0.D0
      vs(2,1)=0.D0
      vs(3,1)=1.D0
      frac(1)=1./npart
      tfrac=frac(1)
      do n=2,npart+1
        alf=dalf*(n-1.0)
        mpart=5*n
        do m=1,mpart
          nps=nps+1
          bet=2.*pi*(m-0.5)/mpart
          vs(1,nps)=sin(alf)*cos(bet)
          vs(2,nps)=sin(alf)*sin(bet)
          vs(3,nps)=cos(alf)
          frac(nps)=1./(mpart*npart)
          tfrac=tfrac+frac(nps)
        enddo
      enddo
      do n=1,nps
        frac(n)=frac(n)/tfrac
      enddo
ccc      print *, 'vs(i,n) and frac(n) for nps = ',nps
ccc      print * , 'tfrac = ',tfrac
ccc      write(*,'(3f10.4,5x,f10.4)') ((vs(i,n),i=1,3),frac(n),n=1,nps)
ccc      write(*,'(10f8.4)') (frac(n),n=1,nps)

      ELSE IF (IOPTION.EQ.2) THEN

c *** calculates coordinates of spread vectors vs in sample axes.
c *** calculates their polar coordinates xps=phi and yps=cos(theta).
      ct=y1
      st=sqrt(1.-ct*ct)
      cp=cos(x1)
      sp=sin(x1)

      h(1,1)=cp*ct
      h(1,2)=-sp
      h(1,3)=cp*st
      h(2,1)=sp*ct
      h(2,2)=cp
      h(2,3)=sp*st
      h(3,1)=-st
      h(3,2)=0.
      h(3,3)=ct

      do n=1,nps
        v1=h(1,1)*vs(1,n)+h(1,2)*vs(2,n)+h(1,3)*vs(3,n)
        v2=h(2,1)*vs(1,n)+h(2,2)*vs(2,n)+h(2,3)*vs(3,n)
        v3=h(3,1)*vs(1,n)+h(3,2)*vs(2,n)+h(3,3)*vs(3,n)
        seca=v1*v1+v2*v2
        if(seca.lt.1.e-06) then
          xps(n)=0.0
        else
          xps(n)=atan2(v2,v1)
        endif
        yps(n)=v3
      enddo

      ENDIF

      return
      end
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C     SUBROUTINE TEXTURE  --->  VERSION OF 01/NOV/2017
C
C *** READS EULER ANGLES OF CRYSTAL WITH RESPECT TO SAMPLE AXES.
C *** OPTIONAL: MAKES STATISTICS TO REDEFINE THE TOTAL NUMBER OF GRAINS
C *** AND RENORMALIZES WEIGHTS
C *** CALCULATES TEXTURE (KERN) FACTORS OF n_th ORDER.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      SUBROUTINE TEXTURE (NGRAIN,ndifpol,ndiftex)
	  
      IMPLICIT NONE 
	  
      integer i,j,k,kx,n,islot,nacum,nfrac,nthorder,nthx
      integer ngrain,ndifpol,ndiftex,iskip
      double precision ang1,ang2,ang3, slot, totwgt, tfac
      double precision wgtmin, wgtmax, wacum, pfrac, aux
	  
      include 'pole8.dim'

      DIMENSION PFRAC(10),NFRAC(10),AUX(3,3)
      dimension tfac(3,3)
      CHARACTER NOMEN*1,PROSA*80

      
      PROSA=PROSA      ! TO FOOL THE COMPILER
      PI=PI            ! TO FOOL THE COMPILER

      READ(ur2,*) NOMEN,NGRAIN
      IF(NGRAIN.GT.NGMAX) THEN
        WRITE(*,*)
        WRITE(*,'('' WARNING !! THERE ARE'',I8,'' ORIENTATIONS IN'',
     #            '' TEXTURE FILE'')') NGRAIN
        WRITE(*,'('' THE MAXIMUM DIMENSION NGMAX IS'',I8)') NGMAX
        WRITE(*,'('' ---> INCREASE PARAMETER NGMAX IN POLE8.DIM'')')
        STOP
      ENDIF
      IF(NOMEN.EQ.'B' .OR. NOMEN.EQ.'b')      THEN
        WRITE(*,11)
      ELSE IF(NOMEN.EQ.'K' .OR. NOMEN.EQ.'k') THEN
        WRITE(*,12)
      ELSE IF(NOMEN.EQ.'R' .OR. NOMEN.EQ.'r') THEN
        WRITE(*,13)
      ELSE
        WRITE(*,14)
        STOP
      ENDIF

   11 FORMAT(/,' READS EULER ANGLES IN BUNGE CONVENTION',
     #         ' - SEQUENCE (phi1,PHI,phi2)')
   12 FORMAT(/,' READS EULER ANGLES IN KOCKS CONVENTION',
     #         ' - SEQUENCE (PSI,THETA,phi)')
   13 FORMAT(/,' READS EULER ANGLES IN ROE CONVENTION',
     #         ' - SEQUENCE (PSI,THETA,phi)')
   14 FORMAT(/,' STOPS EXECUTION BECAUSE EULER ANGLE CONVENTION DOES',
     #         ' NOT AGREE WITH ANY OF THE STANDARD ONES')

      DO N=1,NGRAIN
        READ(ur2,*) ANG1,ANG2,ANG3,WGT(N)
        IF(NOMEN.EQ.'B' .OR. NOMEN.EQ.'b') THEN
          PHI(N)= ANG1
          THE(N)= ANG2
          OME(N)= ANG3
        ELSE IF(NOMEN.EQ.'K' .OR. NOMEN.EQ.'k') THEN
          PHI(N)= ANG1-90.D0
          THE(N)=-ANG2
          OME(N)=-ANG3-90.D0
        ELSE IF(NOMEN.EQ.'R' .OR. NOMEN.EQ.'r') THEN
          PHI(N)= ANG1+90.D0
          THE(N)= ANG2
          OME(N)= ANG3-90.D0
        ENDIF
      ENDDO

      if(ndifpol.eq.1) then
        WRITE(*,*) 'TOTAL NUMBER OF ORIENTATIONS READ IS ',NGRAIN
        WRITE(uw8,'(/)')
        WRITE(uw8,'(/)')
        WRITE(uw8,*) 'TOTAL NUMBER OF ORIENTATIONS READ IS ',NGRAIN
      endif

      WGTMAX=0.D0
      TOTWGT=0.D0
      DO N=1,NGRAIN
        IF(WGT(N).GT.WGTMAX) WGTMAX=WGT(N)
        TOTWGT=TOTWGT+WGT(N)
      ENDDO
      WGTMAX=1.0001*WGTMAX/TOTWGT
      PF_WGT_FACTOR(NDIFTEX)=TOTWGT  ! ACTIVATE FOR PLOTTING PARENT & CHILD TEXTURES
      PF_WGT_FACTOR(NDIFTEX)=1.0     ! FOR PLOTTING INDEPENDENT TEXTURES

      write(*,'('' --> total volume fraction ='',f15.6)') TOTWGT
      write(*,'('' --> pf_wgt_factor ='',f15.6)') PF_WGT_FACTOR(NDIFTEX)

      DO N=1,10
        NFRAC(N)=0
        PFRAC(N)=0.D0
      ENDDO
      DO N=1,NGRAIN
        WGT(N)=WGT(N)/TOTWGT
        ISLOT=10.*WGT(N)/WGTMAX + 1
        NFRAC(ISLOT)=NFRAC(ISLOT)+1
        PFRAC(ISLOT)=PFRAC(ISLOT)+WGT(N)
      ENDDO

      NACUM=0
      WACUM=0.D0
      DO N=1,10
        NACUM=NACUM+NFRAC(N)
        WACUM=WACUM+PFRAC(N)*100.D0
        SLOT =WGTMAX/10.D0*N

        IF(NDIFPOL.eq.1) THEN
          WRITE(uw8,'('' WEIGHTS UP TO'',F8.5,
     #    '' ACCOUNT FOR'',I6,'' GRAINS AND'',F7.2,
     #    '' % OF TOTAL VOLUME'')') SLOT,NACUM,WACUM
          WRITE(*,'('' WEIGHTS UP TO'',F8.5,
     #    '' ACCOUNT FOR'',I6,'' GRAINS AND'',F7.2,
     #    '' % OF TOTAL VOLUME'')') SLOT,NACUM,WACUM
        ENDIF
      ENDDO

C *** CALCULATES ROTATION MATRICES FOR EACH GRAIN.
C *** R(I,J,NGR) TRANSFORMS FROM SPECIMEN TO CRYSTAL AXES.
C *** THE ROWS OF 'R' ARE THE COORDINATES OF CRYSTAL AXES IN SAMPLE AXES.

      WGTMIN=0.      ! default
      ISKIP =1       ! default

C *** ACTIVATE NEXT BLOCK FOR CALCULATING A REDUCED TEXTURE
C      ISKIP =0
      IF(ISKIP.EQ.0) THEN     
      IF(NDIFPOL.EQ.1) THEN 	  
        WRITE(*,*)
        WRITE(*,'('' ENTER 0 TO REDUCE # OF ORIENTS. 1 OTHERWISE'')')
	    READ (*,*) ISKIP
        IF(ISKIP.EQ.0) THEN 	  
          OPEN(UNIT=777,FILE='REDUCED_TEXTURE.TEX',STATUS='UNKNOWN')
          WRITE(*,'('' ENTER MINIMUM GRAIN WEIGHT TO KEEP'')')
	      READ (*,*) WGTMIN
	    ENDIF
	  ENDIF
	  ENDIF

      TOTWGT=0.D0
      K=0
      DO KX=1,NGRAIN
        IF(WGT(KX).GE.WGTMIN) THEN
          K=K+1
          PHI(K)=PHI(KX)
          THE(K)=THE(KX)
          OME(K)=OME(KX)
          WGT(K)=WGT(KX)
          TOTWGT=TOTWGT+WGT(K)
          CALL EULER(2,PHI(K),THE(K),OME(K),AUX)
          DO I=1,3
          DO J=1,3
            R(I,J,K)=AUX(I,J)
          ENDDO
          ENDDO
        ENDIF
      ENDDO

      NGRAIN=K
      DO N=1,NGRAIN
        WGT(N)=WGT(N)/TOTWGT
      ENDDO

      IF(ISKIP.EQ.0 .and. NDIFPOL.EQ.1) THEN 	 
        WRITE(*,'('' REDUCED TEXTURE HAS'',I7,''  GRAINS'')') NGRAIN
        WRITE(*,*)
        WRITE(777,'(''DUMMY'')')
        WRITE(777,'(''DUMMY'')')
        WRITE(777,'(''DUMMY'')')
        WRITE(777,'(a4,i10)') NOMEN,NGRAIN
        WRITE(777,'(3F10.2,F15.6)')
     #	  (PHI(K),THE(K),OME(K),WGT(K),K=1,NGRAIN)
	    CLOSE(UNIT=777)
	  ENDIF

c *** calculates n_th order texture coefficients

      IF(NDIFPOL.EQ.1) THEN
      
c       do nthorder=2,6,2
        do nthorder=1,4
          nthx=nthorder
          tfac(:,:)=0.d0
          do n=1,ngrain
            do i=1,3
            do j=1,3 
	          tfac(i,j)=tfac(i,j)+r(i,j,n)**nthx * wgt(n)
            enddo
            enddo
          enddo
          write(uw8,'(/,i5,''th  order texture coefficients'')') nthx
          write(uw8,'('' crystal axis 1'',5x,3f10.4)') (tfac(1,j),j=1,3)
          write(uw8,'('' crystal axis 2'',5x,3f10.4)') (tfac(2,j),j=1,3)
          write(uw8,'('' crystal axis 3'',5x,3f10.4)') (tfac(3,j),j=1,3)
        enddo

      ENDIF

      RETURN
      END

C ************************************************************************
C --> ODF PROCESSING SUBROUTINES ADDED BY CNT ON APRIL 17 2008
C ************************************************************************

C ************************************************************************
C
C     SUBROUTINE READ_POPLA_SOD   --> VERSION 11/sep/2009
C
C     PRODUCES TWO SETS OF REGULARLY SPACED AND ONE SET OF RANDOMLY
C     DISTRIBUTED EULER ANGLES WITH WEIGHTS (BUNGE NOTATION) STARTING
C     FROM A popLA *.SOD INTENSITY FILE IN KOCKS or BUNGE NOTATION (IFORMAT=0)
C
C     IT CAN ALSO HANDLE ODF FILES GENERATED BY BEARTEX SOFTWARE
C     (IFORMAT=1) AND BY EBSD SOFTWARE (IFORMAT=2)
C
C     ASSUMES MEASUREMENTS ARE DONE AT 5 DEGREES SEPARATION AND AT
C     EACH EXTREME OF THE ANGLE INTERVAL (i.e. 0 & 90 DEGREES).
C
C ************************************************************************

      SUBROUTINE READ_POPLA_SOD (INPUTFILE,OUTFILEID,ICRYSYM,
     #                           DEFAULT,UR2,UW2)
	  
	  IMPLICIT NONE
	  
	  INTEGER CELL_SIZE,FILETYPE,ODFSYM,DEFAULT,UR2,UW2, NGRAIN, IAUX
	  INTEGER NGMXB, ICRYSYM, I,J,K,L, IFORMAT, IX,JX,KX, N, iODF
	  INTEGER NANG1,NANG2,NANG3, NOMEB,NPHIB,NTHEB
	  
	  double precision ANG1, ANG2, ANG3, ODF, rad, PI
	  double precision phix, thex, omex, phib, theb, omeb
	  double precision delphi, delcth, delome, WGTB, TOTWGT
	  
	  

      DIMENSION iODF(73,37,73),ODF(73,37,73),OMEX(73),THEX(37),PHIX(73)

      DIMENSION DELPHI(-1:1),DELCTH(-1:1),DELOME(-1:1)	      
      PARAMETER(NGMXB= 50000)      ! declared in READ_POPLA, CHAOS, ORTHO
      COMMON/TEXB/PHIB(NGMXB),THEB(NGMXB),OMEB(NGMXB),WGTB(NGMXB)
      CHARACTER    NOMEN*1
      CHARACTER*80 INPUTFILE,OUTFILEID*5,TEXTFILE(3)

      PI=4.D0*DATAN(1.D0)
      RAD=PI/180.

      WRITE(*,*) '  will create outfileid.FUL (large regular texture)'
      WRITE(*,*) '  will create outfileid.RED (small regular texture)'
      WRITE(*,*) '  will create outfileid.RAN (medium random texture)'

      OPEN(UNIT=UR2,FILE=INPUTFILE,STATUS='OLD')

      ODFSYM=0
      IF(DEFAULT.EQ.1) THEN
        WRITE(*,*) 'ENTER SYMMETRY OF INPUT ODF: '
        WRITE(*,*) '  (0) NO SYMMETRY ENFORCED (full Euler space)'
        WRITE(*,*) '  (1) ORTHOTROPIC SYMMETRY ENFORCED (reduced Euler)'
        WRITE(*,*)
        READ(*,*)   ODFSYM
      ENDIF

      IF(ICRYSYM.NE.1 .and. ICRYSYM.NE.2 .and. ICRYSYM.NE.5) THEN
        WRITE(*,'('' CRYSTAL SYM'',I3,''  NOT PROGRAMMED'')') ICRYSYM
        STOP
      ENDIF

      IF(ODFSYM.EQ.0)  NANG1=72
      IF(ODFSYM.EQ.1)  NANG1=19
      NANG2=19
      IF(ICRYSYM.EQ.1) NANG3=19      ! cubic
      IF(ICRYSYM.EQ.2) NANG3=13      ! hexag
      IF(ICRYSYM.EQ.5) NANG3=37      ! ortho

      READ(UR2,*)
      READ(UR2,*) NOMEN
      IF(NOMEN.EQ.'K' .OR. NOMEN.EQ.'k') FILETYPE=2      ! Kocks
      IF(NOMEN.EQ.'B' .OR. NOMEN.EQ.'b') FILETYPE=3      ! Bunge
      IF(NOMEN.EQ.'M' .OR. NOMEN.EQ.'m') FILETYPE=4      ! Mathies

      IFORMAT=0      ! hardwired for the default popLA format
      IFORMAT=3      ! hardwire for MTEX cubic crystal format 

C ************************************************************************
      IF(IFORMAT.EQ.0) THEN

C *** READS INTENSITY FROM ODF FILE WITH POPLA FORMAT & KOCKS CONVENTION
C     (FILETYPE=2) OR BUNGE CONVENTION (FILETYPE=3)
C
C *** WHEN EULER ANGLES ARE IN KOCKS CONVENTION (POPLA FILES):
C     ang1=PSI  : CCW ROTATION OF CRYSTAL AROUND 'z' SAMPLE AXIS.
C     ang2=THETA: CCW ROTATION OF CRYSTAL AROUND 'y' CRYSTAL AXIS.
C     ang3=PHI  : CW  ROTATION OF CRYSTAL AROUND 'z' CRYSTAL AXIS.
C      0<PSI<90 (or 360)  ;  0<THE<90  ;  0<PHI<90       (cubics)
C      0<PSI<90 (or 360)  ;  0<THE<90  ;  0<PHI<60       (hexagonals)
C      0<PSI<90 (or 360)  ;  0<THE<90  ;  0<PHI<180      (orthorhombic)
C *** THE FIRST 19x19 BLOCK CORRESPONDS TO PSI=0.
C     THE FIRST LINE IN THE BLOCK IS FOR THETA=0 AND VARYING PHI.
C     THE SECOND LINE IN THE BLOCK IS FOR THETA=5 AND VARYING PHI.
C     THE SECOND 19x19 BLOCK CORRESPONDS TO PSI=5...AND SO ON.
C ************************************************************************

      DO I=1,NANG1

        IF(I.GE.2) THEN
          DO L=1,3
            READ(UR2,*)
          ENDDO
        ENDIF

        DO J=1,NANG2
         IF(ICRYSYM.LE.2) READ(UR2,'(1X,19I4)') (iODF(I,J,K),K=1,NANG3)
         IF(ICRYSYM.EQ.5) THEN
           READ(UR2,'(1X,18I4)') (iODF(I,J,K),K= 1,18)
           READ(UR2,'(1X,19I4)') (iODF(I,J,K),K=19,37)
         ENDIF
        ENDDO
      ENDDO
      DO I=1,NANG1
        DO J=1,NANG2
          DO K=1,NANG3
            ODF(I,J,K)=FLOAT(iODF(I,J,K))
          ENDDO
        ENDDO
      ENDDO

      ENDIF      ! end of IFORMAT=0

C ************************************************************************
      IF(IFORMAT.EQ.1) THEN

C *** READS INTENSITY FROM ODF FILE WITH BEARTEX FORMAT AND MATHIES
C     CONVENTION (FILETYPE=4) --> this option has not been thoroughly checked
C
C *** WHEN EULER ANGLES ARE IN MATHIES CONVENTION:
C     ang1=ALPHA  : CCW ROTATION OF CRYSTAL AROUND 'z' SAMPLE AXIS.
C     ang2=BETA   : CCW ROTATION OF CRYSTAL AROUND 'y' CRYSTAL AXIS.
C     ang3=GAMMA  : CCW ROTATION OF CRYSTAL AROUND 'z' CRYSTAL AXIS.
C      0<ALP<360  ;  0<BET<90  ;  0<GAM<90       (cubics)
C      0<ALP<360  ;  0<BET<90  ;  0<GAM<60       (hexagonals)
C      0<ALP<360  ;  0<BET<90  ;  0<GAM<180      (orthorhombic)
C *** THE FIRST 76-LINE BLOCK CORRESPONDS TO GAMMA=0.
C     THE FIRST 4 LINES IN THE BLOCK IS BETA=0 AND VARYING ALPHA.
C     THE NEXT  4 LINES IN THE BLOCK IS BETA=5 AND VARYING ALPHA.
C     THE LAST  4 LINES IN THE BLOCK IS BETA=90 AND VARYING ALPHA.
C     THE SECOND 76-LINE BLOCK CORRESPONDS TO GAMMA=5...AND SO ON.
C ************************************************************************

      DO K=1,NANG3

        IF(K.EQ.1) THEN
          DO L=1,5
            READ(UR2,*)
          ENDDO
        ENDIF
        IF(K.GE.2) THEN
          DO L=1,8
            READ(UR2,*)
          ENDDO
        ENDIF

        READ(UR2,'(1X,18I4)') ((iODF(I,J,K),I=1,NANG1),J=1,NANG2)

      ENDDO

      DO I=1,NANG1
        DO J=1,NANG2
          DO K=1,NANG3
            ODF(I,J,K)=FLOAT(iODF(I,J,K))
          ENDDO
        ENDDO
      ENDDO

      ENDIF      ! end of IFORMAT=1

C ************************************************************************
      IF(IFORMAT.EQ.2) THEN

C *** READS AN ODF GENERATED BY EBSD SOFTWARE (Rodney McCabe) BASED ON
C     BUNGE NOTATION
C     -->        0<phi1<360 , 0<PHI<180 , 0<phi2<360 (every 5 deg)
C ************************************************************************

        DO I=1,73
          DO J=1,37
            DO K=1,73
              READ(UR2,*) ANG1,ANG2,ANG3,ODF(I,J,K)
            ENDDO
          ENDDO
        ENDDO

      ENDIF      ! end of IFORMAT=2

C ************************************************************************
      IF(IFORMAT.EQ.3) THEN

C *** TENTATIVE PROCESING OF MTEX SOD FOR CUBIC CRYSTAL ORIGINATING IN EBSD 
C     -->        0<phi1<360 , 0<PHI<90 , 0<phi2<85 (every 5 deg)
C ************************************************************************

        READ (UR2,*)
        READ (UR2,*)
        READ (UR2,*)
        READ (UR2,*)		
        DO K=1,18
          DO J=1,19
            DO I=1,72
              READ(UR2,*) ANG1,ANG2,ANG3,ODF(I,J,K)
            ENDDO
          ENDDO
        ENDDO
        DO J=1,19
          DO I=1,72
            ODF(I,J,19)=ODF(I,J,1)
          ENDDO
        ENDDO
        NANG3=19

      ENDIF      ! end of IFORMAT=3

C ************************************************************************

      IF(ODFSYM.EQ.0) THEN
        DO J=1,NANG2
          DO K=1,NANG3
            ODF(73,J,K)=ODF(1,J,K)
          ENDDO
        ENDDO
        NANG1=73
      ENDIF

      NPHIB=NANG1
      NTHEB=NANG2
      NOMEB=NANG3

      DO I=1,NPHIB
        DO J=1,NTHEB
          DO K=1,NOMEB
            IF(ODF(I,J,K).LT.0.) ODF(I,J,K)=0.
          ENDDO
        ENDDO
      ENDDO

      CLOSE(UNIT=UR2)

C *** CALCULATES BUNGE ANGLES DEPENDING ON THE INPUT CONVENTION.
C     PHIB = PSIR+90 = PSIK+90 = ALPHAM+90
C     THEB = THER    = THEK    = BETAM
C     OMEB = PHIR-90 =-PHIK-90 = GAMMAM-90
C     HOWEVER, HERE I ASSUME OMEB=PHIR BECAUSE THE ONLY INSTANCE WHERE
C     ROE IS USED IS IN Chalk River FILES OF HOLDEN & ROOT WHERE REFERENCE
C     AXES ARE: XC=(1 0 -1 0) & YC=(1 1 -2 0) FOR HEXAGONALS.
C     CUBIC CRYSTALS ARE INVARIANT TO THIS 90 DEGREE DIFFERENCE IN PHIR.

      DO I=1,NOMEB
        IF(FILETYPE.EQ.2) OMEX(I)=-(I-1.)*5. -90.
        IF(FILETYPE.EQ.3) OMEX(I)= (I-1.)*5.
        IF(FILETYPE.EQ.4) OMEX(I)= (I-1.)*5. -90.
      ENDDO

      DO J=1,NTHEB
        THEX(J)=(J-1.)*5.
      ENDDO

      DO K=1,NPHIB
        IF(FILETYPE.EQ.2) PHIX(K)=(K-1.)*5. +90.
        IF(FILETYPE.EQ.3) PHIX(K)=(K-1.)*5.
        IF(FILETYPE.EQ.4) PHIX(K)=(K-1.)*5. +90.
      ENDDO

C *******************************************************************
C *** LOOPS OVER 5 & 10 deg INTEGRATION CELLS IN EULER SPACE
C *******************************************************************

      DO CELL_SIZE=5,10,5

C ************************************************************************
      IF (CELL_SIZE.EQ.5) THEN
C
C *** CALCULATES VOLUME FRACTIONS IN A CELL OF 5 DEGREES IN EULER SPACE.
C *** ASSIGNS ORIENTATION TO THE CENTER OF A PARALLELEPIPEDIC CELL, THE
C *** CORNERS OF WHICH ARE DEFINED BY ORIENTATIONS WHERE THE INTENSITY
C *** WAS MEASURED.
C *** THIS PROCEDURE PUTS ALL ORIENTATIONS INSIDE THE EULER DOMAIN AND
C *** AVOIDS GIVING A SPECIAL TREATMENT TO ORIENTATIONS BELONGING TO THE
C *** BOUNDARY.
C *** THE VOLUME FRACTION IS GIVEN BY A WEIGHTED AVERAGE OF INTENSITIES.

      L=1
      DO I=1,NPHIB-1
        DELPHI( 1)= (PHIX(I+1)-PHIX(I  ))/2.*RAD

        DO J=1,NTHEB-1
          DELCTH( 1)= (COS(THEX(J+1)*RAD)-COS(THEX(J  )*RAD))/2.

          DO K=1,NOMEB-1
            DELOME( 1)= (OMEX(K+1)-OMEX(K  ))/2.*RAD

            PHIB(L)= PHIX(I)+DELPHI(1)/RAD
            THEB(L)= ACOS( COS(THEX(J)*RAD)+DELCTH(1))/RAD
            OMEB(L)= OMEX(K)+DELOME(1)/RAD

            WGTB(L)=0.
            DO IX=0,1
              DO JX=0,1
                DO KX=0,1
                  WGTB(L)=WGTB(L) + ODF(I+IX,J+JX,K+KX)*
     #                              ABS( DELPHI(1)*DELCTH(1)*DELOME(1))
                ENDDO
              ENDDO
            ENDDO
            L=L+1
          ENDDO
        ENDDO
      ENDDO
      NGRAIN=L-1

      ENDIF               ! END OF CONDITION CELL_SIZE=5

C ************************************************************************
      IF (CELL_SIZE.EQ.10) THEN

C *** CALCULATES VOLUME FRACTIONS WITHIN A CELL OF 10 DEGREES IN EULER SPACE,
C *** INTEGRATING OVER THE CENTRAL AND THE NEAREST MEASURED INTENSITIES.

      L=1
      DO I=2,NPHIB-1,2
        DELPHI(-1)= (PHIX(I  )-PHIX(I-1))/2.*RAD
        DELPHI( 0)= (PHIX(I+1)-PHIX(I-1))/2.*RAD
        DELPHI( 1)= (PHIX(I+1)-PHIX(I  ))/2.*RAD

        DO J=2,NTHEB-1,2
          DELCTH(-1)= (COS(THEX(J  )*RAD)-COS(THEX(J-1)*RAD))/2.
          DELCTH( 0)= (COS(THEX(J+1)*RAD)-COS(THEX(J-1)*RAD))/2.
          DELCTH( 1)= (COS(THEX(J+1)*RAD)-COS(THEX(J  )*RAD))/2.

          DO K=2,NOMEB-1,2
            DELOME(-1)= (OMEX(K  )-OMEX(K-1))/2.*RAD
            DELOME( 0)= (OMEX(K+1)-OMEX(K-1))/2.*RAD
            DELOME( 1)= (OMEX(K+1)-OMEX(K  ))/2.*RAD

            PHIB(L)= PHIX(I)
            THEB(L)= ACOS( COS(THEX(J-1)*RAD)+DELCTH(0))/RAD
            OMEB(L)= OMEX(K)

            WGTB(L)=0.
            DO IX=-1,1
              DO JX=-1,1
                DO KX=-1,1
                  WGTB(L)=WGTB(L) + ODF(I+IX,J+JX,K+KX)*
     #                           ABS( DELPHI(IX)*DELCTH(JX)*DELOME(KX))
                ENDDO
              ENDDO
            ENDDO
            L=L+1
          ENDDO
        ENDDO
      ENDDO
      NGRAIN=L-1

      ENDIF               ! END OF CONDITION CELL_SIZE=10

C ************************************************************************

      IF(NGRAIN.GT.NGMXB) THEN
        WRITE(*,'('' MAXIMUM GRAIN DIMENSION WAS EXCEEDED !!'')')
        WRITE(*,'('' INCREASE PARAMETER NGMXB TO AT LEAST'',I7)') NGRAIN
        STOP
      ENDIF

C *** NORMALIZES WEIGHTS

      TOTWGT=0.
      DO N=1,NGRAIN
        TOTWGT=TOTWGT+WGTB(N)
      ENDDO

      WRITE(*,'('' ngrain & total weight'',i10,e12.3)') ngrain,totwgt

      DO N=1,NGRAIN
        WGTB(N)=WGTB(N)/TOTWGT
      ENDDO

C *** GENERATES THE MIRROR RELATED ORIENTATIONS BY 'MIRRORING' THE AXES
C *** OF THE CRYSTAL IN SAMPLE AXES (ROWS OF 'A'), AND CALLING EULER TO
C *** CALCULATE THE TRANSFORMATION MATRICES.
C *** RENORMALIZES WEIGHTS AND QUADRUPLES THE NUMBER OF ORIENTATIONS.

      IF(CELL_SIZE.EQ.5.AND.DEFAULT.EQ.1.AND.ODFSYM.EQ.0) THEN
        WRITE(*,*)
        WRITE(*,*) 'ENTER 1 TO ORTHO-SYMMETRIZE THE TEXTURE (0 IF NOT)'
        WRITE(*,*)
        READ (*,*)  ODFSYM
      ENDIF

      IF(ODFSYM.EQ.1) THEN
        IF(4*NGRAIN.GT.NGMXB) THEN
          WRITE(*,'('' DIMENSION NGMXB WILL BE EXCEEDED !!'')')
          WRITE(*,'('' INCREASE PARAMETER TO AT LEAST'',I7)') 4*NGRAIN
          STOP
        ENDIF
        CALL ORTHO (NGRAIN)
      ENDIF

      IF(CELL_SIZE.EQ. 5) TEXTFILE(1)=OUTFILEID//'.FUL'
      IF(CELL_SIZE.EQ.10) TEXTFILE(2)=OUTFILEID//'.RED'
      IAUX=CELL_SIZE/5

      OPEN(UNIT=UW2,FILE=TEXTFILE(IAUX),STATUS='UNKNOWN')
        WRITE(UW2,*) 'AXES OF THE REPRESENTATIVE ELLIPSOID'
        WRITE(UW2,*) '   1.0   1.0   1.0'
        WRITE(UW2,'(''DISCRETE TEXTURE FROM ODF FILE '',A40)') INPUTFILE
        WRITE(UW2,'(''B'',I8)') NGRAIN
        WRITE(UW2,'(3F10.2,F15.8)') (PHIB(L),THEB(L),OMEB(L),WGTB(L),
     #                             L=1,NGRAIN)
      CLOSE(UNIT=UW2)

      ENDDO      ! END OF DO CELL_SIZE

      CALL CHAOS (INPUTFILE,OUTFILEID,TEXTFILE,FILETYPE,ICRYSYM,
     #            UR2,UW2,DEFAULT)

      RETURN
      END
C
C *********************************************************************
C     SUBROUTINE CHAOS   --->   VERSION SEP/11/2009
C
C *** ASSIGNS WEIGHTS TO A RANDOM DISTRIBUTION OF ORIENTATIONS IN ORDER
C *** TO REPRODUCE THE TEXTURE READ FROM AN ODF FILE.
C *********************************************************************

      SUBROUTINE CHAOS (INPUTFILE,OUTFILEID,TEXTFILE,FILETYPE,ICRYSYM,
     #                  UR2,UW2,DEFAULT)
	  
	  IMPLICIT NONE
	  
	  CHARACTER*80 NOMEN*1,TEXTFILE(3),OUTFILEID*5,INPUTFILE
      INTEGER      FILETYPE,UR2,UW2,DEFAULT
      integer 	   NGMXB, NNEIGHMX, ICRYSYM
	  INTEGER      IG, JRAN, L, MGX, NEIGHID, NF, NGRAIN, NGRAINRAN, NGRAINX
	  INTEGER      NGX, NR, NGRAINFUL, NGRAINX, NNEIGH, NTAGS
	  
	  double precision PI, PHIB, THEB, OMEB, WGTB, PHIR, THER, OMER
	  double precision RANDOM1, RANDOM2, RANDOM3, SEPA, SEPAMAX
	  double precision SHIFTPHI, SHIFTOME, RAN2, WGTR
		
      PARAMETER(NGMXB= 50000)      ! declared in READ_POPLA, CHAOS, ORTHO
      PARAMETER(NNEIGHMX=100)
      COMMON/TEXB/PHIB(NGMXB),THEB(NGMXB),OMEB(NGMXB),WGTB(NGMXB)
      DIMENSION   PHIR(NGMXB),THER(NGMXB),OMER(NGMXB),WGTR(NGMXB)
      DIMENSION   NTAGS(NGMXB),NNEIGH(NGMXB),NEIGHID(NGMXB,NNEIGHMX)
	  
      PI=4.*ATAN(1.)
      NOMEN=NOMEN

C *** GENERATES RANDOM ORIENTATIONS 0<phir<360, 0<ther<90, 0<omer<90,60,180
C *** SHIFTS RANDOM ANGLES INSIDE THE INTERVAL USED BY EACH CONVENTION.

      NGRAINRAN=5000
ccc   IF(DEFAULT.EQ.1) THEN
        PRINT *
        PRINT *, ' enter # of random orientations to be used for'
        PRINT *, ' representing this texture (final # may be larger)'
        PRINT *
        READ * , NGRAINRAN
        IF(NGRAINRAN.GT.NGMXB) THEN
          PRINT *, ' number of grains exceed maximum dim NGMXB !!!'
          STOP
        ENDIF
ccc   ENDIF

      IF(FILETYPE.EQ.3) THEN      ! Bunge
        SHIFTPHI=0.
        SHIFTOME=0.
      ENDIF
      IF(FILETYPE.EQ.2) THEN      ! Kocks
        SHIFTPHI= 90.
        IF(ICRYSYM.EQ.1) SHIFTOME=-180.
        IF(ICRYSYM.EQ.2) SHIFTOME=-150.
        IF(ICRYSYM.EQ.5) SHIFTOME=-270.
      ENDIF
      IF(FILETYPE.EQ.4) THEN      ! Mathies
        SHIFTPHI= 90.
c       IF(ICRYSYM.EQ.1) SHIFTOME=  0.
c       IF(ICRYSYM.EQ.2) SHIFTOME=-30.
c       IF(ICRYSYM.EQ.5) SHIFTOME= 90.
c --> changed as follows according to Merkel's suggestion. CNT has not checked
        IF(ICRYSYM.EQ.1) SHIFTOME=-90.
        IF(ICRYSYM.EQ.2) SHIFTOME=-90.
        IF(ICRYSYM.EQ.5) SHIFTOME= 90.
      ENDIF

      JRAN=-1     !defines seed for subsequent calls to random generator
      DO NR=1,NGRAINRAN
        RANDOM1=RAN2(JRAN)
        RANDOM2=RAN2(JRAN)
        RANDOM3=RAN2(JRAN)
        PHIR(NR)=360.*RANDOM1 +SHIFTPHI
        THER(NR)=ACOS(RANDOM2)*180./PI
        IF(ICRYSYM.EQ.1) OMER(NR)= 90.*RANDOM3 +SHIFTOME      ! cubic
        IF(ICRYSYM.EQ.2) OMER(NR)= 60.*RANDOM3 +SHIFTOME      ! hexagonal
        IF(ICRYSYM.EQ.5) OMER(NR)=180.*RANDOM3 +SHIFTOME      ! orthogonal
        WGTR(NR)=  0.
      ENDDO

      OPEN(UNIT=UR2,FILE=TEXTFILE(1),STATUS='OLD')   ! opens *.FUL
        READ(UR2,*)
        READ(UR2,*)
        READ(UR2,*)
        READ(UR2,*) NOMEN,NGRAINFUL
        DO NF=1,NGRAINFUL
          READ(UR2,*) PHIB(NF),THEB(NF),OMEB(NF),WGTB(NF)
        ENDDO
      CLOSE(UNIT=UR2)

      DO NF=1,NGRAINFUL
        NTAGS(NF)=0
      ENDDO

      SEPAMAX=10.
c     PRINT *, 'ENTER ANGULAR SEPARATION TO ASSIGN RANDOM '
c     PRINT *, 'ORIENTATIONS (default= 10 deg) --> '
c     READ * , SEPAMAX

      DO NR=1,NGRAINRAN
        NNEIGH(NR)=0
        DO NF=1,NGRAINFUL
          SEPA=SQRT((PHIB(NF)-PHIR(NR))**2+(THEB(NF)-THER(NR))**2+
     #              (OMEB(NF)-OMER(NR))**2)
          IF(SEPA.LE.SEPAMAX) THEN
            NNEIGH(NR)=NNEIGH(NR)+1
            NEIGHID(NR,NNEIGH(NR))=NF
            NTAGS(NF) =NTAGS(NF) +1
          ENDIF
        ENDDO
        IF(NNEIGH(NR).GT.NNEIGHMX) THEN
          WRITE(*,'('' MAXIMUM NNEIGH DIMENSION EXCEEDED'')')
          WRITE(*,'('' FOR NR='',I5,''   NNEIGH='',I5)') NR,NNEIGH(NR)
          STOP
        ENDIF
      ENDDO

      NGRAINX=0
      DO NR=1,NGRAINRAN
        IF(NNEIGH(NR).GE.1) THEN
          NGRAINX=NGRAINX+1
          PHIR(NGRAINX)=PHIR(NR)
          THER(NGRAINX)=THER(NR)
          OMER(NGRAINX)=OMER(NR)
          DO IG=1,NNEIGH(NR)
            NGX=NEIGHID(NR,IG)
            MGX=NTAGS(NGX)
            WGTR(NGRAINX)=WGTR(NGRAINX)+WGTB(NGX)/FLOAT(MGX)
          ENDDO
        ENDIF
      ENDDO

      DO NF=1,NGRAINFUL
        IF(NTAGS(NF).EQ.0) THEN
          NGRAINX=NGRAINX+1
          PHIR(NGRAINX)=PHIB(NF)
          THER(NGRAINX)=THEB(NF)
          OMER(NGRAINX)=OMEB(NF)
          WGTR(NGRAINX)=WGTB(NF)
        ENDIF
      ENDDO
      WRITE(*,'(''NGRAINS IN RANDOM FILE'',I8)') NGRAINX

      NGRAIN=NGRAINX

      TEXTFILE(3)=OUTFILEID//'.RAN'
      OPEN(UNIT=UW2,FILE=TEXTFILE(3),STATUS='UNKNOWN')
        WRITE(UW2,*) 'AXES OF THE REPRESENTATIVE ELLIPSOID'
        WRITE(UW2,*) '   1.0   1.0   1.0'
        WRITE(UW2,'(''DISCRETE TEXTURE FROM FILE  '',A40)') INPUTFILE
        WRITE(UW2,'(''B'',I8)') NGRAIN
        WRITE(UW2,'(3F10.2,F15.8)') (PHIR(L),THER(L),OMER(L),WGTR(L),
     #                             L=1,NGRAIN)
      CLOSE(UNIT=UW2)

      RETURN
      END
C
C **************************************************************************
C     SUBROUTINE ORTHO       --->      version SEPT/2007
C
C *** GENERATES THE MIRROR RELATED ORIENTATIONS BY 'MIRRORING' THE AXES
C *** OF THE CRYSTAL IN SAMPLE AXES (ROWS OF 'A'), AND CALLING EULER TO
C *** CALCULATE THE TRANSFORMATION MATRICES. THE SIGN IS CHANGED IN
C *** ALL MIRROR MATRICES IN ORDER TO RECONSTITUTE THE DEXTROGIROUS FRAME.
C *** RENORMALIZES WEIGHTS AND QUADRUPLES NUMBER OF ORIENTATIONS.
C **************************************************************************

      SUBROUTINE ORTHO (NGRAIN)
	  
	   IMPLICIT NONE
	   
	   integer ngrain, ng, i, j, ngmxb, mirror, index
	   double precision A, R, ang1, ang2, ang3, PHIB, THEB, OMEB, WGTB
	   double precision sign
	   
      DIMENSION R(3,3,4),A(3,3)

      PARAMETER(NGMXB= 50000)      ! declared IN READ_POPLA, CHAOS, ORTHO
      COMMON/TEXB/PHIB(NGMXB),THEB(NGMXB),OMEB(NGMXB),WGTB(NGMXB)

      DO NG=1,NGRAIN

        CALL EULER (2,PHIB(NG),THEB(NG),OMEB(NG),A)
        DO I=1,3
          DO J=1,3
            R(I,J,1)= A(I,J)
          ENDDO
        ENDDO
        WGTB(NG)=WGTB(NG)/4.

C *** MIRROR x1 ******************************
        DO I=1,3
          DO J=1,3
            SIGN=1.
            IF(J.EQ.1) SIGN=-1.
            R(I,J,2)= A(I,J) * SIGN * (-1.)
          ENDDO
        ENDDO

C *** MIRROR x2 ******************************
        DO I=1,3
          DO J=1,3
            SIGN=1.
            IF(J.EQ.2) SIGN=-1.
            R(I,J,3)= A(I,J) * SIGN * (-1.)
          ENDDO
        ENDDO

C *** MIRROR x1 AND x2 ***********************
        DO I=1,3
          DO J=1,3
            SIGN=1.
            IF(J.EQ.1 .OR. J.EQ.2) SIGN=-1.
            R(I,J,4)= A(I,J) * SIGN
          ENDDO
        ENDDO

        DO MIRROR=1,4
          DO I=1,3
            DO J=1,3
              A(I,J)=R(I,J,MIRROR)
            ENDDO
          ENDDO
          CALL EULER (1,ANG1,ANG2,ANG3,A)
          INDEX=(MIRROR-1)*NGRAIN+NG
          PHIB(INDEX)=ANG1
          THEB(INDEX)=ANG2
          OMEB(INDEX)=ANG3
          WGTB(INDEX)=WGTB(NG)
        ENDDO

      ENDDO

      NGRAIN=4*NGRAIN

      RETURN
      END
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
      FUNCTION ran2(idum)
      INTEGER idum,IM1,IM2,IMM1,IA1,IA2,IQ1,IQ2,IR1,IR2,NTAB,NDIV
      double precision ran2,AM,EPS,RNMX
      PARAMETER (IM1=2147483563,IM2=2147483399,AM=1./IM1,IMM1=IM1-1,
     *IA1=40014,IA2=40692,IQ1=53668,IQ2=52774,IR1=12211,IR2=3791,
     *NTAB=32,NDIV=1+IMM1/NTAB,EPS=1.2e-7,RNMX=1.-EPS)
      INTEGER idum2,j,k,iv(NTAB),iy
      SAVE iv,iy,idum2
      DATA idum2/123456789/, iv/NTAB*0/, iy/0/
      if (idum.le.0) then
        idum=max(-idum,1)
        idum2=idum
        do 11 j=NTAB+8,1,-1
          k=idum/IQ1
          idum=IA1*(idum-k*IQ1)-k*IR1
          if (idum.lt.0) idum=idum+IM1
          if (j.le.NTAB) iv(j)=idum
11      continue
        iy=iv(1)
      endif
      k=idum/IQ1
      idum=IA1*(idum-k*IQ1)-k*IR1
      if (idum.lt.0) idum=idum+IM1
      k=idum2/IQ2
      idum2=IA2*(idum2-k*IQ2)-k*IR2
      if (idum2.lt.0) idum2=idum2+IM2
      j=1+iy/NDIV
      iy=iv(j)-idum2
      iv(j)=idum
      if(iy.lt.1)iy=iy+IMM1
      ran2=min(AM*iy,RNMX)
      return
      END
C  (C) Copr. 1986-92 Numerical Recipes Software #>,13.
